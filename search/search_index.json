{"config":{"lang":["es"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Taller de React con Typescript","text":"<p>Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba.</p> <p>Plantilla</p> <p>Existe una plantilla que incluye todo el cap\u00edtulo Crear el proyecto base completo. Si lo deseas puedes usarla para tener el sistema exactamente configurado como lo tenemos en el tutorial.</p> <p>La plantilla, adem\u00e1s, se puede ejecutar directamente en Codespaces por si quieres empezar a trabajar.</p> <p>Puedes clonar la plantilla desde la web del repositorio: https://github.com/aulasoftwarelibre/taller-de-next-con-typescript-template</p> <p>O abrirla directamente pulsando aqu\u00ed:</p> <p></p>"},{"location":"#agradecimientos","title":"Agradecimientos","text":"<p>Este taller ha sido impartido por las siguientes personas:</p> <ul> <li>Sergio G\u00f3mez</li> </ul>"},{"location":"#licencia","title":"Licencia","text":"<p>El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)</p>"},{"location":"api-rest/","title":"Integraci\u00f3n con servicios REST","text":"<p>En el desarrollo de aplicaciones modernas, la capacidad de interactuar eficientemente con servicios externos a trav\u00e9s de APIs es fundamental. Esta secci\u00f3n est\u00e1 dedicada a explorar c\u00f3mo podemos integrar nuestra aplicaci\u00f3n Next.js con diferentes servicios API, enfoc\u00e1ndonos principalmente en la comunicaci\u00f3n con APIs REST.</p>"},{"location":"api-rest/#protocolo-http","title":"Protocolo HTTP","text":"<p>La comunicaci\u00f3n entre el frontend de una aplicaci\u00f3n y el backend se realiza a menudo a trav\u00e9s de APIs REST, utilizando el protocolo HTTP. Este m\u00e9todo de integraci\u00f3n permite a las aplicaciones web interactuar con bases de datos y servidores sin necesidad de recargar la p\u00e1gina, ofreciendo una experiencia de usuario fluida y din\u00e1mica. En esta secci\u00f3n, exploraremos los tipos de peticiones HTTP m\u00e1s comunes en APIs REST y c\u00f3mo se utilizan para diferentes operaciones CRUD (Crear, Leer, Actualizar, Eliminar).</p>"},{"location":"api-rest/#tipos-de-peticiones-en-api-rest","title":"Tipos de peticiones en API REST","text":"<ul> <li> <p>GET: Se utiliza para solicitar datos de un recurso espec\u00edfico. Las peticiones GET deben ser solo de lectura y no modificar los datos del servidor Una caracter\u00edstica importante de GET es que los par\u00e1metros de la solicitud se env\u00edan en la URL. Los navegadores tienden a cachear las respuestas de las peticiones GET, lo que puede ser \u00fatil para mejorar la eficiencia y velocidad de carga de las aplicaciones web.</p> </li> <li> <p>POST: Se usa para enviar datos a un servidor para crear o actualizar un recurso. Los datos se env\u00edan en el cuerpo de la solicitud, no en la URL, lo que permite enviar informaci\u00f3n m\u00e1s compleja y segura. A diferencia de GET, POST no es cacheado por los navegadores, lo que lo hace m\u00e1s seguro para operaciones que implican cambios o la transferencia de informaci\u00f3n sensible.</p> </li> <li> <p>PUT: Similar a POST, pero se utiliza principalmente para actualizar recursos existentes. Si el recurso no existe, PUT puede crear uno nuevo.</p> </li> <li> <p>DELETE: Como su nombre indica, se utiliza para eliminar recursos especificados.</p> </li> <li> <p>PATCH: Se usa para aplicar actualizaciones parciales a un recurso. A diferencia de PUT, que reemplaza completamente el recurso, PATCH modifica solo los campos especificados.</p> </li> </ul>"},{"location":"api-rest/#diferencias-clave-entre-get-y-post","title":"Diferencias clave entre GET y POST","text":"<ul> <li>Cach\u00e9 del navegador: GET puede ser cacheado, lo que reduce el tiempo de carga y mejora la eficiencia de la aplicaci\u00f3n. POST, al contener datos en el cuerpo del mensaje, no se cachea, proporcionando una capa adicional de seguridad para datos sensibles.</li> <li>Ubicaci\u00f3n de los datos: En GET, los datos se pasan a trav\u00e9s de la URL, lo que puede limitar la cantidad de informaci\u00f3n enviada y es menos seguro. En POST, los datos se env\u00edan en el cuerpo de la solicitud, permitiendo mayor cantidad de informaci\u00f3n y mayor seguridad.</li> <li>Uso: GET se utiliza para solicitar datos sin afectarlos, mientras que POST se utiliza para enviar datos al servidor, afectando cambios o creando recursos.</li> </ul>"},{"location":"api-rest/#creando-un-servidor-rest","title":"Creando un servidor REST","text":"<p>Como este tutorial trata sobre frontend, no vamos a desarrollar un back. Usaremos un servidor de pruebas que permite enviar y guardar datos desde un fichero de texto.</p> <p>Para ello vamos a ejecutar lo siguiente:</p> <pre><code>npm add --save-dev json-server\nnpx npm-add-script -f -k db:start -v \"mkdir -p node_modules/.cache &amp;&amp; echo '{\\\"counters\\\":[{\\\"id\\\": 1, \\\"value\\\": 0}]}' &gt; node_modules/.cache/db.json &amp;&amp; json-server --port 4000 --watch node_modules/.cache/db.json\"\n</code></pre> <p>Y ya podemos ejecutarlo en un terminal aparte:</p> <pre><code>npm run db:start\n</code></pre> <p>Podemos acceder desde el navegador, que por defecto hace peticiones GET, y visualizar los datos que contiene:</p> <ul> <li>Ver todos los contadores: http://localhost:4000/counters</li> <li>Ver un contador por su id: http://localhost:4000/counters/1</li> </ul> <p>Para crear datos, necesitamos usar POST. No podemos usar el navegador, pero podemos usar un cliente como <code>curl</code>:</p> <p>Example</p> <p>Vamos a crear un par de contadores</p> <pre><code>curl -X POST http://localhost:4000/counters --json '{\"id\": \"2\", \"value\": 0}'\ncurl -X POST http://localhost:4000/counters --json '{\"id\": \"3\", \"value\": -10}'\n</code></pre> <p>Para actualizar datos, tendremos que usar la url del contador. Dependiendo del servidor, deberemos usar POST, PUT o PATCH.</p> <p>Example</p> <p>Si el ejemplo anterior nos devolvi\u00f3 un contador con el id <code>2</code>, podemos actualizarlo as\u00ed:</p> <pre><code>curl -X PATCH http://localhost:4000/counters/2 --json '{\"value\": 10}'\n</code></pre> <p>O podemos usar PUT:</p> <pre><code>curl -X PUT http://localhost:4000/counters/2 --json '{\"value\": 10}'\n</code></pre> <p>Podemos ver ahora que deber\u00edamos tener tres contadores:</p> <pre><code>curl -X GET http://localhost:4000/counters\n</code></pre>"},{"location":"api-rest/#accediendo-a-los-datos-del-servidor-desde-react","title":"Accediendo a los datos del servidor desde React","text":"<p>Para manejar las solicitudes HTTP de manera efectiva y eficiente en React, podemos utilizar la combinaci\u00f3n de Axios para realizar las peticiones y la librer\u00eda SWR para el fetching y caching de datos. Esto nos permite crear aplicaciones m\u00e1s r\u00e1pidas y con mejor respuesta al usuario.</p>"},{"location":"api-rest/#instalacion-de-swr","title":"Instalaci\u00f3n de SWR","text":"<p>Primero, instala <code>swr</code>, que nos ayudar\u00e1 con el fetching, el cacheo y la revalidaci\u00f3n de datos. Ejecuta el siguiente comando en tu terminal:</p> <pre><code>npm add swr\n</code></pre> <p>Para simplificar las peticiones HTTP vamos a centralizar la URL base del servicio y una funci\u00f3n <code>fetcher</code> que reutilizaremos desde SWR. Crea el archivo <code>src/utils/fetcher.ts</code> con el siguiente contenido.</p>"},{"location":"api-rest/#configuracion-del-fetcher","title":"Configuraci\u00f3n del fetcher","text":"src/utils/fetcher.ts<pre><code>export const API_BASE_URL = 'http://localhost:4000'\n\nexport async function fetcher(url: string) {\n  const response = await fetch(`${API_BASE_URL}${url}`)\n\n  if (!response.ok) {\n    throw new Error('Request failed')\n  }\n\n  return response.json()\n}\n</code></pre>"},{"location":"api-rest/#uso-de-swr-con-el-fetcher","title":"Uso de SWR con el Fetcher","text":"<p>Una vez que tienes tu funci\u00f3n fetcher definida, puedes usarla con SWR en tus componentes React para acceder a los datos del servidor. SWR manejar\u00e1 autom\u00e1ticamente el caching, la revalidaci\u00f3n y otras optimizaciones. Para mantener el ejemplo ordenado, vamos a separar la l\u00f3gica en un servicio y un hook reutilizable antes de llegar al componente.</p>"},{"location":"api-rest/#servicio-del-contador","title":"Servicio del contador","text":"src/services/counter.ts<pre><code>import { API_BASE_URL } from '@/utils/fetcher'\n\nexport async function updateCounter(id: number, value: number) {\n  const response = await fetch(`${API_BASE_URL}/counters/${id}`, {\n    body: JSON.stringify({ value }),\n    headers: { 'Content-Type': 'application/json' },\n    method: 'PATCH',\n  })\n\n  if (!response.ok) {\n    throw new Error('Unable to update counter')\n  }\n\n  return response.json()\n}\n</code></pre>"},{"location":"api-rest/#hook-usecounter","title":"Hook <code>useCounter</code>","text":"src/hooks/use-counter.ts<pre><code>'use client'\n\nimport useSWR from 'swr'\n\nimport { fetcher } from '@/utils/fetcher'\nimport { updateCounter } from '@/services/counter'\n\nexport function useCounter(id: number) {\n  const { data, isLoading, mutate } = useSWR(`/counters/${id}`, fetcher)\n\n  const counter: number = data?.value ?? 0\n\n  const onIncrement = async (value: number) =&gt; {\n    const updated = await updateCounter(id, counter + value)\n\n    mutate({ ...(data ?? {}), value: updated.value }, false)\n  }\n\n  const onReset = async () =&gt; {\n    const updated = await updateCounter(id, 0)\n\n    mutate({ ...(data ?? {}), value: updated.value }, false)\n  }\n\n  return { counter, isLoading, onIncrement, onReset }\n}\n</code></pre>"},{"location":"api-rest/#componente-counter","title":"Componente <code>Counter</code>","text":"<p>Vamos a actualizar nuestro componente <code>Counter</code> para que ahora use la API en vez de almacenar el estado localmente. Si recargamos la p\u00e1gina, lo primero que notaremos es que ahora los contadores tienen el valor por defecto que les hemos colocado. Si usamos los botones para modificarlos y recargamos, el nuevo valor se reflejar\u00e1.</p> src/components/counter/counter.tsx<pre><code>'use client'\n\nimport {\n  Button,\n  ButtonGroup,\n  Card,\n  CardFooter,\n  CardHeader,\n  Skeleton,\n} from '@heroui/react'\nimport {\n  ArrowPathIcon,\n  ChevronDoubleLeftIcon,\n  ChevronDoubleRightIcon,\n  ChevronLeftIcon,\n  ChevronRightIcon,\n} from '@heroicons/react/24/solid'\n\nimport { useCounter } from '@/hooks/use-counter'\nimport { CounterProperties } from './types'\n\nexport function Counter({ id, step }: CounterProperties) {\n  const { counter, isLoading, onIncrement, onReset } = useCounter(id)\n\n  if (isLoading) {\n    return (\n      &lt;Card className=\"w-[240px] h-[132px]\"&gt;\n        &lt;Skeleton&gt;\n          &lt;div className=\"h-24 rounded-lg bg-default-300\"&gt;&lt;/div&gt;\n        &lt;/Skeleton&gt;\n      &lt;/Card&gt;\n    )\n  }\n\n  return (\n    &lt;Card className=\"w-[240px] bg-gradient-to-br from-violet-500 to-fuchsia-500\"&gt;\n      &lt;CardHeader className=\"flex-col items-start\"&gt;\n        &lt;div className=\"flex flex-col\"&gt;\n          &lt;p className=\"text-tiny text-white/60 uppercase font-bold\"&gt;\n            Contador #{id}\n          &lt;/p&gt;\n          &lt;p className=\"text-white font-medium text-large\"&gt;\n            El contador vale {counter}.\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/CardHeader&gt;\n      &lt;CardFooter className=\"justify-center\"&gt;\n        &lt;ButtonGroup&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Decrement counter by step\"\n            onClick={() =&gt; onIncrement(-step * 10)}\n          &gt;\n            &lt;ChevronDoubleLeftIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              -{step * 10}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Decrement counter\"\n            onClick={() =&gt; onIncrement(-step)}\n          &gt;\n            &lt;ChevronLeftIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              -{step}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Reset counter\"\n            onClick={() =&gt; onReset()}\n          &gt;\n            &lt;ArrowPathIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Increment counter\"\n            onClick={() =&gt; onIncrement(step)}\n          &gt;\n            &lt;ChevronRightIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              +{step}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Increment counter by step\"\n            onClick={() =&gt; onIncrement(step * 10)}\n          &gt;\n            &lt;ChevronDoubleRightIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              +{step * 10}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n        &lt;/ButtonGroup&gt;\n      &lt;/CardFooter&gt;\n    &lt;/Card&gt;\n  )\n}\n</code></pre> <p>Dentro del hook reaprovechamos la misma funci\u00f3n <code>onIncrement</code> para sumar o restar valores, pasando n\u00fameros negativos cuando queremos decrementar. As\u00ed evitamos duplicar l\u00f3gica y mantenemos el ejemplo centrado en un \u00fanico flujo de mutaci\u00f3n: llamar al endpoint con el nuevo valor y refrescar la cach\u00e9 de SWR.</p>"},{"location":"counter/","title":"Componente contador","text":"<p>En este cap\u00edtulo, exploraremos las t\u00e9cnicas fundamentales de gesti\u00f3n de estado en React utilizando el hook useState y la Context API. Aprenderemos c\u00f3mo utilizar useState para administrar el estado local de un componente y c\u00f3mo compartir ese estado entre varios componentes a trav\u00e9s de la composici\u00f3n y el contexto. Descubriremos las ventajas y consideraciones de cada enfoque para tomar decisiones informadas sobre c\u00f3mo gestionar eficazmente el estado en nuestras aplicaciones React.</p>"},{"location":"counter/#componente-contador","title":"Componente contador","text":"<p>Para este cap\u00edtulo vamos a usar un componente nuevo llamado <code>Counter</code>. Vamos a crear el componente del contador, un fichero con los tipos o propiedades que usa y el fichero con su Story:</p> src/components/counter/counter.tsx<pre><code>'use client' // (1)!\n\nimport {\n  ArrowPathIcon,\n  ChevronDoubleLeftIcon,\n  ChevronDoubleRightIcon,\n  ChevronLeftIcon,\n  ChevronRightIcon,\n} from '@heroicons/react/24/outline'\nimport {\n  Button,\n  ButtonGroup,\n  Card,\n  CardFooter,\n  CardHeader,\n} from '@heroui/react'\n\ninterface CounterProperties {\n  id: number\n  step: number\n}\n\nexport function Counter({ id, step }: CounterProperties) {\n  const counter = 0\n\n  return (\n    &lt;Card className=\"w-60 bg-linear-to-br from-violet-500 to-fuchsia-500\"&gt;\n      &lt;CardHeader className=\"flex-col items-start\"&gt;\n        &lt;div className=\"flex flex-col\"&gt;\n          &lt;p className=\"text-tiny text-white/60 uppercase font-bold\"&gt;\n            Contador #{id}\n          &lt;/p&gt;\n          &lt;p className=\"text-white font-medium text-large\"&gt;\n            El contador vale {counter}.\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/CardHeader&gt;\n      &lt;CardFooter className=\"justify-center\"&gt;\n        &lt;ButtonGroup&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Decrement counter with step\"\n          &gt;\n            &lt;ChevronDoubleLeftIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              -{step * 10}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button isIconOnly size=\"md\" aria-label=\"Decrement counter\"&gt;\n            &lt;ChevronLeftIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              -{step}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button isIconOnly size=\"md\" aria-label=\"Reset counter\"&gt;\n            &lt;ArrowPathIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n          &lt;/Button&gt;\n          &lt;Button isIconOnly size=\"md\" aria-label=\"Increment counter\"&gt;\n            &lt;ChevronRightIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              +{step}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            isIconOnly\n            size=\"md\"\n            aria-label=\"Increment counter with step\"\n          &gt;\n            &lt;ChevronDoubleRightIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              +{step * 10}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n        &lt;/ButtonGroup&gt;\n      &lt;/CardFooter&gt;\n    &lt;/Card&gt;\n  )\n}\n</code></pre> <ol> <li>Recordemos que esta l\u00ednea es obligatoria cuando se use un router con soporte de React Server Components, como es el caso de la nueva versi\u00f3n de Next, y el componente use hooks.</li> </ol> src/stories/components/counter.stories.ts<pre><code>import type { Meta, StoryObj } from '@storybook/react'\n\nimport { Counter } from '@/components/counter/counter'\n\nconst meta = {\n  component: Counter,\n  parameters: {\n    layout: 'centered',\n  },\n  title: 'Components/Counter',\n} satisfies Meta&lt;typeof Counter&gt;\n\nexport default meta\ntype Story = StoryObj&lt;typeof meta&gt;\n\nexport const Basic: Story = {\n  args: {\n    id: 1,\n    step: 1,\n  },\n}\n</code></pre> <p>Si visitamos ahora el componente en Storybook veremos lo siguiente:</p> <p></p>"},{"location":"dependencies/","title":"Dependencias","text":"<p>Para comenzar a desarrollar aplicaciones con React en Linux, necesitar\u00e1s instalar algunas herramientas esenciales. En este cap\u00edtulo, te guiaremos a trav\u00e9s del proceso de instalaci\u00f3n de Node.js y Visual Studio Code (VSCode), dos herramientas clave para el desarrollo de aplicaciones React.</p>"},{"location":"dependencies/#instalacion-de-nodejs","title":"Instalaci\u00f3n de Node.js","text":"<p>Node.js es un entorno de ejecuci\u00f3n de JavaScript que te permite ejecutar c\u00f3digo JavaScript en el lado del servidor y tambi\u00e9n en el navegador. React utiliza Node.js para gestionar sus dependencias y automatizar tareas de desarrollo. Puedes descargar node para tu distribuci\u00f3n de Linux siguiendo las instrucciones de la web oficial.</p> <p>Una vez que lo hayas hecho verifica que Node.js y npm se hayan instalado correctamente ejecutando los siguientes comandos:</p> <pre><code>    node -v\n    npm -v\n</code></pre> <p>Deber\u00edas ver las versiones de Node.js y npm que has instalado. Ahora tienes Node.js y npm instalados en tu sistema Linux, lo que te permitir\u00e1 trabajar con React.</p>"},{"location":"dependencies/#instalacion-de-visual-studio-code-vscode","title":"Instalaci\u00f3n de Visual Studio Code (VSCode)","text":"<p>Visual Studio Code es un entorno de desarrollo de c\u00f3digo abierto extremadamente popular que ofrece una amplia gama de extensiones y herramientas para facilitar el desarrollo de aplicaciones React. Puedes instalar VSCode en Linux desde la web oficial.</p> <p>Una vez instalado, puedes abrir Visual Studio Code ejecutando code en la terminal o busc\u00e1ndolo en tu men\u00fa de aplicaciones.</p>"},{"location":"heroui/","title":"Configurando HeroUI","text":"<p>Ya tenemos Next instalado, pero ahora necesitamos integrar el resto de componentes que vamos a necesitar para trabajar.</p>"},{"location":"heroui/#heroui","title":"HeroUI","text":"<p>Esta librer\u00eda de componentes se apoya en TailwindCSS con lo que su instalaci\u00f3n nos dar\u00e1 muy pocos problemas y viene bien descrita en la web oficial. En cualquier caso, vamos a instalarlo con el paquete <code>@heroicons/react</code>, que nos permitir\u00e1 tener un paquete de iconos en la aplicaci\u00f3n y con <code>next-themes</code> para poder aplicar tema oscuro o claro.</p> <pre><code>npm install @heroui/react framer-motion @heroicons/react next-themes\n</code></pre> <p>Ahora necesitamos configurar el fichero de estilos de <code>tailwindcss</code> para que soporte los componentes de HeroUI. Creamos el siguiente archivo:</p> src/app/hero.ts<pre><code>import { heroui } from '@heroui/react'\nexport default heroui()\n</code></pre> <p>E instalamos el plugin en el fichero de estilos de Next. Borramos todo el contenido y lo dejamos as\u00ed:</p> src/app/globals.css<pre><code>@import \"tailwindcss\";\n@plugin \"./hero.ts\";\n@source \"../../node_modules/@heroui/theme/dist/**/*.{js,ts,jsx,tsx}\";\n@custom-variant dark (&amp;:is(.dark *));\n</code></pre>"},{"location":"heroui/#dark-theme","title":"Dark theme","text":"<p>Para poder aplicar el tema oscuro o claro en nuestra aplicaci\u00f3n, necesitamos configurar una librer\u00eda llamada <code>next-theme</code>. En este caso HeroUI tambi\u00e9n lo explica en la web oficial.</p> <p>Necesitamos, en cualquier caso crear un nuevo fichero con los providers de HeroUI con el siguiente contenido:</p> src/app/providers.tsx<pre><code>'use client'\n\nimport { HeroUIProvider } from '@heroui/system'\nimport { useRouter } from 'next/navigation'\nimport type { ThemeProviderProps } from 'next-themes'\nimport { ThemeProvider as NextThemesProvider } from 'next-themes'\nimport type * as React from 'react'\n\nexport interface ProvidersProps {\n  children: React.ReactNode\n  themeProps?: ThemeProviderProps\n}\n\ndeclare module '@react-types/shared' {\n  interface RouterConfig {\n    routerOptions: NonNullable&lt;\n      Parameters&lt;ReturnType&lt;typeof useRouter&gt;['push']&gt;[1]\n    &gt;\n  }\n}\n\nexport function Providers({ children, themeProps }: ProvidersProps) {\n  const router = useRouter()\n\n  return (\n    &lt;HeroUIProvider navigate={router.push}&gt;\n      &lt;NextThemesProvider {...themeProps}&gt;{children}&lt;/NextThemesProvider&gt;\n    &lt;/HeroUIProvider&gt;\n  )\n}\n</code></pre> <p>Info</p> <p>La notaci\u00f3n <code>'use client'</code> es exclusiva de algunos frameworks con soporte de <code>React Server Components</code>. Se ver\u00e1 su uso durante el curso.</p> <p>Y este archivo de providers se debe cargar en el layout principal:</p> src/app/layout.tsx<pre><code>import type { Metadata, Viewport } from 'next'\nimport { Geist, Geist_Mono } from 'next/font/google'\nimport './globals.css'\nimport { Providers } from './providers'\n\nconst geistSans = Geist({\n  variable: '--font-geist-sans',\n  subsets: ['latin'],\n})\n\nconst geistMono = Geist_Mono({\n  variable: '--font-geist-mono',\n  subsets: ['latin'],\n})\n\nexport const metadata: Metadata = {\n  description: 'Aplicaci\u00f3n del taller de Next del Aula de Software Libre',\n  title: 'Taller de Next con Typescript',\n}\n\nexport const viewport: Viewport = {\n  themeColor: [\n    { media: '(prefers-color-scheme: light)', color: 'white' },\n    { media: '(prefers-color-scheme: dark)', color: 'black' },\n  ],\n}\n\nexport default function RootLayout({\n  children,\n}: Readonly&lt;{\n  children: React.ReactNode\n}&gt;) {\n  return (\n    &lt;html lang=\"en\" suppressHydrationWarning&gt;\n      &lt;body\n        className={`${geistSans.variable} ${geistMono.variable} bg-background text-foreground antialiased`}\n      &gt;\n        &lt;Providers themeProps={{ attribute: 'class', defaultTheme: 'dark' }}&gt;\n          {children}\n        &lt;/Providers&gt;\n      &lt;/body&gt;\n    &lt;/html&gt;\n  )\n}\n</code></pre>"},{"location":"heroui/#nuestro-primer-componente-themeswitcher","title":"Nuestro primer componente: ThemeSwitcher","text":"<p>Para poder ver en funcionamiento el selector de tema claro/oscuro, vamos a crear un switch para cambiar de un tema a otro.</p> <p>Para eso crearemos el siguiente componente:</p> src/components/theme-switcher/theme-switcher.tsx<pre><code>'use client'\n\nimport { MoonIcon, SunIcon } from '@heroicons/react/24/solid'\nimport { Switch } from '@heroui/react'\nimport { useTheme } from 'next-themes'\nimport { useEffect, useState } from 'react'\n\n/**\n * Theme dark/light switcher\n */\nexport function ThemeSwitcher() {\n  const [mounted, setMounted] = useState(false) // (1)\n  const { setTheme, theme } = useTheme() // (2)\n\n  useEffect(() =&gt; {\n    setMounted(true) // (3)\n  }, [setMounted])\n\n  if (!mounted) return null\n\n  return (\n    &lt;Switch\n      defaultSelected={theme === 'light'}\n      size=\"md\"\n      color=\"secondary\"\n      onClick={() =&gt; setTheme(theme === 'dark' ? 'light' : 'dark')}\n      startContent={&lt;SunIcon /&gt;}\n      endContent={&lt;MoonIcon /&gt;}\n    /&gt;\n  )\n}\n</code></pre> <ol> <li>Hook para comprobar si el componente ya ha sido montado.</li> <li>Hook proporcionado por next-themes para conocer el tema y cambiarlo.</li> <li>Esta funci\u00f3n se ejecuta una sola vez, justo despu\u00e9s de que el componente se haya montado, y cambia el estado del hook a true.</li> </ol> <p>Vamos a probar a a\u00f1adir nuestro componente a la pagina principal:</p> src/app/page.tsx<pre><code>import Image from 'next/image'\nimport { ThemeSwitcher } from '@/components/theme-switcher/theme-switcher'\n\nexport default function Home() {\n  return (\n    &lt;div className=\"flex min-h-screen items-center justify-center bg-zinc-50\n     font-sans dark:bg-black\"&gt;\n      &lt;main className=\"flex min-h-screen w-full max-w-3xl flex-col items-center\n       justify-between bg-white px-16 py-32 sm:items-start dark:bg-black\"&gt;\n        &lt;div className=\"flex min-h-10 w-full justify-between\"&gt;\n          &lt;Image\n            alt=\"Next.js logo\"\n            className=\"dark:invert\"\n            height={20}\n            priority\n            src=\"/next.svg\"\n            width={100}\n          /&gt;\n          &lt;ThemeSwitcher /&gt; {/* (1) */}\n        &lt;/div&gt;\n        &lt;div className=\"flex flex-col items-center gap-6 text-center\n         sm:items-start sm:text-left\"&gt;\n          &lt;h1 className=\"max-w-xs font-semibold text-3xl text-black leading-10\n           tracking-tight dark:text-zinc-50\"&gt;\n            To get started, edit the page.tsx file.\n          &lt;/h1&gt;\n</code></pre> <ol> <li>A\u00f1adimos el componente despu\u00e9s del logo de Vercel. El IDE importar\u00e1 autom\u00e1ticamente el componente.</li> </ol> <p>Warning</p> <p>En este caso no puedes copiar y pegar el c\u00f3digo. Aprende a importar y usar componentes.</p> <p>Hay dos maneras de escribir una marca HTML. Si la marca tiene contenido:</p> <pre><code>&lt;div&gt;Content&lt;/div&gt;\n</code></pre> <p>Y si no lo tiene, como es el caso de nuestro componente:</p> <pre><code>&lt;ThemeSwitcher /&gt;\n</code></pre> <p>Ahora, ya tendremos la p\u00e1gina principal con nuestro componente para cambiar al tema claro:</p> <p></p>"},{"location":"install/","title":"Creando el boilerplate","text":"<p>Crear un boilerplate desde cero para hacer funcionar m\u00faltiples herramientas de Node.js, como React, NextUI, Jest y Storybook, puede ser una tarea desafiante y propensa a errores, especialmente para los novatos. Los problemas de configuraci\u00f3n, las dependencias en conflicto y las incompatibilidades pueden ser una fuente de frustraci\u00f3n significativa. Esto puede desanimar a los principiantes y hacer que el proceso de inicio sea m\u00e1s largo y complicado de lo deseado, en lugar de permitirles centrarse directamente en el desarrollo de sus aplicaciones.</p>"},{"location":"install/#instalar-next","title":"Instalar Next","text":"<p>Aunque Next tiene una forma can\u00f3nica de instalarse a trav\u00e9s de la herramienta <code>npx</code>, el proyecto tienen una multitud de ejemplos donde podemos descargar next ya integrado con alguna librer\u00eda que nos interese.</p> <pre><code>npx create-next-app@latest taller-de-next-con-typescript-code --biome --yes\n</code></pre> <p>Info</p> <p>Vamos a usar biome para mantener el correcto formato de nuestros ficheros en vez de eslint que es el software de correcci\u00f3n por defecto.</p> <p>Despu\u00e9s de lo cual podemos abrir el nuevo directorio con nuestro IDE y ejecutar el servidor de desarrollo:</p> <pre><code>cd taller-de-next-con-typescript-code\nnpm run dev\n</code></pre> <p></p>"},{"location":"install/#linting","title":"Linting","text":"<p>El linting es una pr\u00e1ctica esencial en el desarrollo de software que consiste en analizar el c\u00f3digo fuente en busca de errores, inconsistencias y malas pr\u00e1cticas. En este curso utilizaremos Biome, una herramienta moderna escrita en Rust que combina linting y formateo en un \u00fanico binario, simplificando la configuraci\u00f3n y acelerando las comprobaciones respecto a la cl\u00e1sica pareja ESLint + Prettier.</p> <p>Biome incluye reglas de estilo y de calidad listas para usarse, detecta patrones problem\u00e1ticos y mantiene un formato consistente del c\u00f3digo sin necesidad de herramientas adicionales. Si vienes de ESLint te resultar\u00e1 familiar: muchas reglas tienen equivalentes directos y puedes extender la configuraci\u00f3n mediante un \u00fanico fichero <code>biome.json</code>.</p> <p>Al crear el proyecto con <code>--biome</code>, Next.js ya genera la configuraci\u00f3n inicial y un script <code>npm run lint</code> que ejecuta <code>biome check</code>. Aun as\u00ed conviene revisar el archivo <code>biome.json</code> para ajustar reglas como el orden de los imports, la pol\u00edtica de comillas o cualquier preferencia de estilo que tenga tu equipo.</p>"},{"location":"install/#ultracite","title":"Ultracite","text":"<p>Aunque Next ya viene con una configuraci\u00f3n por defecto de biome, el proyecto Ultracite proporciona una configuraci\u00f3n m\u00e1s avanzada, adem\u00e1s de que nos permite configurar otros aspectos como el editor, los hooks de git e incluso la interacci\u00f3n con agentes de programaci\u00f3n. Ejecuta lo siguiente:</p> <pre><code>npx ultracite@latest init --editors vscode --frameworks next --integrations lefthook\n</code></pre> <p>Info</p> <p>El instalador nos preguntar\u00e1 si queremos instalar la integraci\u00f3n con alg\u00fan agente. En este curso no vamos a usar ninguno, as\u00ed que puedes ignorar este paso y darle a INTRO.</p> <p>Y a continuaci\u00f3n vamos a editar el archivo <code>biome.jsonc</code> con este contenido:</p> biome.jsonc<pre><code>{\n  \"$schema\": \"./node_modules/@biomejs/biome/configuration_schema.json\",\n  \"extends\": [\n    \"ultracite/core\",\n    \"ultracite/next\"\n  ],\n  \"linter\": {\n    \"rules\": {\n      \"style\": {\n        \"useConsistentTypeDefinitions\": {\n          \"level\": \"warn\",\n          \"options\": {\n            \"style\": \"interface\"\n          }\n        }\n      }\n    }\n  },\n  \"javascript\": {\n    \"formatter\": {\n      \"semicolons\": \"asNeeded\",\n      \"quoteStyle\": \"single\"\n    }\n  }\n}\n</code></pre> <p>Note</p> <p>No vamos a explicar lo que significa cada opci\u00f3n, se recomienda ir a la documentacion de Biome para ver el significado de las reglas utilizadas. Estas reglas son solo un ejemplo y cada persona o grupo de desarrollo puede tener las suyas propias. As\u00ed que no deben tomarse como algo dogm\u00e1tico.</p> <p>Y vamos a configurar nuestro proyecto para que use Biome con estas dos \u00f3rdenes:</p> <pre><code>npm pkg set scripts.lint=\"ultracite check\"\nnpm pkg set scripts.format=\"ultracite fix\"\n</code></pre> <p>Ahora si ejecutamos el linter en la l\u00ednea de comandos:</p> <pre><code>npm run lint\n</code></pre> <p>Veremos que encuentra algunos errores de lintado. Podemos corregirlos autom\u00e1ticamente ejecutando lo siguiente:</p> <p><pre><code>npm run format\n</code></pre> <pre><code>```bash\nnpm run lint -- --fix\n</code></pre></p>"},{"location":"install/#lintado-con-visual-studio-code","title":"Lintado con Visual Studio Code","text":"<p>Obviamente no es muy c\u00f3modo. Podemos hacerlo de forma autom\u00e1tica al guardar el fichero en vscode. Biome para ello nos ha creado este fichero:</p> .vscode/settings.json<pre><code>{\n  \"editor.defaultFormatter\": \"esbenp.prettier-vscode\",\n  \"[javascript]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[typescript]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[javascriptreact]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[typescriptreact]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[json]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[jsonc]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[css]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"[graphql]\": {\n    \"editor.defaultFormatter\": \"biomejs.biome\"\n  },\n  \"typescript.tsdk\": \"node_modules/typescript/lib\",\n  \"editor.formatOnSave\": true,\n  \"editor.formatOnPaste\": true,\n  \"emmet.showExpandedAbbreviation\": \"never\",\n  \"editor.codeActionsOnSave\": {\n    \"source.fixAll.biome\": \"explicit\",\n    \"source.organizeImports.biome\": \"explicit\"\n  }\n}\n</code></pre> <p>Esta configuraci\u00f3n de vscode es exclusiva para este proyecto, se puede configurar para que lo haga en todos los que creemos si configuramos estas opciones en el entorno de usuario. </p> <p>Probablemente veamos un error indicando que el plugin <code>esbenp.prettier-vscode</code>  y el plugin <code>biomejs.biome</code>  no existen, debido a que probablemente no lo tengamos instalado. Los IDE suelen proporcionar plugins que facilitan el trabajo. Si quieres, puedes instalar ess extensiones manualmente o crear este fichero que te recomendar\u00e1 instalar varias extensiones que usaremos en este taller. </p> .vscode/extensions.json<pre><code>{\n  \"recommendations\": [\n    \"esbenp.prettier-vscode\",\n    \"vitest.explorer\",\n    \"bradlc.vscode-tailwindcss\",\n    \"biomejs.biome\",\n    \"usernamehw.errorlens\"\n  ]\n}\n</code></pre> <p>Se recomienda ver el Taller de VSCode.</p>"},{"location":"install/#git-hooks","title":"Git hooks","text":"<p>Hemos visto ya como formatear autom\u00e1ticamente nuestros ficheros desde vscode, pero eso tiene un problema, si alg\u00fan fichero se edita de otra manera o hay alg\u00fan problema con el editor, puede que se nos escape alg\u00fan fichero con el  formato incorrecto.</p> <p>Necesitamos estar completamente seguro que no vamos a commitear a nuestro repositorio de git ning\u00fan fichero que viole nuestras reglas de lintado.</p> <p>Para eso git proporciona una serie de hooks, que son scripts que se ejecutan en determinadas acciones (pull, commit, pre-commit, ...). Podemos aprovecharlos para comprobar que los ficheros son correctos.</p> <p>Info</p> <p>Saber Git es esencial para los programadores ya que facilita el seguimiento de cambios, la colaboraci\u00f3n en equipo y la gesti\u00f3n eficiente del c\u00f3digo fuente, lo que garantiza un desarrollo de software ordenado y eficaz. Se recomienda seguir el Taller de Git.</p>"},{"location":"install/#configurar-lefthook","title":"Configurar lefthook","text":"<p>Con este paquete podremos comprobar el lintado de nuestros archivos antes de  hacer commit. Lefthook se encarga de configurar los hooks y de comprobar que los ficheros modificados son correctos.</p> <p>Afortunadamente, Ultracite ya se ha encargado de instalarlo y configurarlo, asi que no tendremos que hacer nada m\u00e1s por ahora.</p>"},{"location":"install/#configurar-conventional-commits","title":"Configurar conventional commits","text":"<p>Conventional Commits es una convenci\u00f3n de nomenclatura para los mensajes de confirmaci\u00f3n (commits) en proyectos de desarrollo de software. Su objetivo es estandarizar la estructura y el contenido de los mensajes de confirmaci\u00f3n, lo que facilita la comprensi\u00f3n y el seguimiento de los cambios en un repositorio. Los mensajes de confirmaci\u00f3n siguen un formato espec\u00edfico, que incluye un encabezado conciso y opcionalmente un cuerpo y pies de p\u00e1gina, todos dise\u00f1ados para proporcionar informaci\u00f3n clara sobre qu\u00e9 cambios se realizaron en el c\u00f3digo.</p> <p>La estructura de un mensaje de commit es la siguiente:</p> <pre><code>&lt;type&gt;[optional scope]: &lt;description&gt;\n\n[optional body]\n\n[optional footer(s)]\n</code></pre> <p>Vamos a ayudarnos de lefthook para configurarlo. Instalamos como siempre las dependencias:</p> <pre><code>npm install --save-dev @commitlint/{config-conventional,cli}\necho \"export default { extends: ['@commitlint/config-conventional'] }\" &gt; .commitlintrc.mjs\n</code></pre> <p>Y ahora configuramos lefthook editando el archivo <code>lefthook.yml</code> y a\u00f1adimos las lineas marcadas.</p> lefthook.yml<pre><code>pre-commit:\n  jobs:\n    - run: npx ultracite fix\n      glob:\n        - \"*.js\"\n        - \"*.jsx\"\n        - \"*.ts\"\n        - \"*.tsx\"\n        - \"*.json\"\n        - \"*.jsonc\"\n        - \"*.css\"\n      stage_fixed: true\n\ncommit-msg:\n  commands:\n    \"lint commit message\":\n      run: npx --no -- commitlint --edit \"$1\"\n</code></pre> <p>Y sincronizamos la configuraci\u00f3n de lefthook con los hooks de git:</p> <pre><code>npm exec lefthook install\n</code></pre> <p>Y una vez hecho todo eso intentamos ya, por fin, guardar los cambios y veremos como act\u00faan los hooks de git:</p> <pre><code>git add .\ngit commit -m \"chore: configure linting, git hooks and conventional commits\"\n</code></pre> <p>Note</p> <p>Si queremos ver como falla si el mensaje no sigue conventional commits podemos ejecutar esta prueba:</p> <pre><code>git commit --allow-empty -m \"invalid message\"\n</code></pre>"},{"location":"install/#vitest","title":"Vitest","text":"<p>Para completar nuestro entorno, vamos a configurar Vitest. Vitest es un marco de pruebas (testing framework) moderno y r\u00e1pido, dise\u00f1ado espec\u00edficamente para el ecosistema de Vite, pero que tambi\u00e9n se adapta perfectamente al desarrollo de aplicaciones React. Ofrece una experiencia de prueba eficiente y optimizada, facilitando la realizaci\u00f3n de pruebas unitarias, de integraci\u00f3n y funcionales. Gracias a su compatibilidad con la API de Jest, Vitest permite una transici\u00f3n suave para aquellos proyectos que desean mejorar su velocidad y eficiencia en las pruebas.</p> <p>Instalamos las dependencias:</p> <pre><code>npm install --save-dev vitest @vitejs/plugin-react jsdom @testing-library/react \\\n    @testing-library/dom vite-tsconfig-paths @testing-library/jest-dom\n</code></pre> <p>Y creamos el archivo de configuraci\u00f3n:</p> vitest.config.mts<pre><code>import react from '@vitejs/plugin-react'\nimport tsconfigPaths from 'vite-tsconfig-paths'\nimport { defineConfig } from 'vitest/config'\n\nexport default defineConfig({\n  plugins: [tsconfigPaths(), react()],\n  test: {\n    environment: 'jsdom',\n    setupFiles: ['./vitest.setup.mts'],\n  },\n})\n</code></pre> <p>A continuaci\u00f3n creamos el siguiente fichero:</p> vitest.setup.mts<pre><code>import * as matchers from '@testing-library/jest-dom/matchers'\nimport { cleanup } from '@testing-library/react'\nimport { afterEach, expect } from 'vitest'\n\nexpect.extend(matchers)\n\nafterEach(() =&gt; {\n  cleanup()\n})\n</code></pre> <p>Y con el siguiente comando podremos a\u00f1adir un comando test a npm:</p> <pre><code>npm pkg set scripts.test=\"vitest\"\n</code></pre>"},{"location":"install/#crear-un-test-de-ejemplo","title":"Crear un test de ejemplo","text":"<p>Para comprobar que vitest funciona correctamente vamos a crear un peque\u00f1o test. Si usas la plantilla en un futuro este ya no te servir\u00e1, as\u00ed que recuerda actualizarlo.</p> src/app/page.spec.tsx<pre><code>import { render, screen } from '@testing-library/react'\nimport { expect, test } from 'vitest'\n\nimport Page from './page'\n\ntest('App Router: Works with Server Components', () =&gt; {\n  render(&lt;Page /&gt;)\n  expect(screen.getByRole('main')).toBeDefined()\n})\n</code></pre> <p>Y a continuaci\u00f3n ejecutamos las pruebas para comprobar que se ejecuta sin problemas:</p> <pre><code>npm run test\n</code></pre> <p>Por defecto vitest se ejecuta en modo <code>watch</code>. Eso significa que al terminar de pasar los test no termina, sino que se queda observando si los ficheros cambian para volver a ejecutarlos. Resulta muy \u00fatil si haces TDD. Para terminar simplemente pulsa Ctrl+C en la consola.</p> <p>Ejercicio</p> <p>Se deja como ejercicio, guardar los cambios en git con la configuraci\u00f3n de Vitest y siguiendo conventional commits para el mensaje.</p> <p>Tip</p> <p>A partir de aqu\u00ed ya tendr\u00edamos una plantilla b\u00e1sica para trabajar con Next. Puede usarse ya como plantillas de repositorios para Github o esperar a la siguiente secci\u00f3n donde se a\u00f1adir\u00e1 una librer\u00eda de componentes y la herramienta Storybook, aunque eso provoca que la plantilla sea menos vers\u00e1til.</p> <p>Si te has perdido en alguna parte, puedes descargar la plantilla en nuestro repositorio y partir de ah\u00ed.</p> <p>Simplemente pulsa en el bot\u00f3n <code>Use this template</code> y despu\u00e9s clona tu copia en tu equipo.</p>"},{"location":"new-project/","title":"Introducci\u00f3n","text":"<p>En este cap\u00edtulo, aprenderemos a crear un nuevo proyecto de React utilizando Next.js y el framework de dise\u00f1o NextUI. React es una biblioteca de JavaScript ampliamente utilizada para construir interfaces de usuario interactivas, mientras que Next.js es un framework de React que facilita la creaci\u00f3n de aplicaciones web avanzadas con rutas y renderizaci\u00f3n del lado del servidor. NextUI es una biblioteca de componentes que proporciona componentes de interfaz de usuario preestilizados y personalizables, lo que acelera el proceso de dise\u00f1o y desarrollo.</p>"},{"location":"new-project/#instalacion","title":"Instalaci\u00f3n","text":"<p>Crear un boilerplate desde cero para hacer funcionar m\u00faltiples herramientas de Node.js, como React, NextUI, Vitest y Storybook, puede ser una tarea desafiante y propensa a errores, especialmente para los novatos. Los problemas de configuraci\u00f3n, las dependencias en conflicto y las incompatibilidades pueden ser una fuente de frustraci\u00f3n significativa. Esto puede desanimar a los principiantes y hacer que el proceso de inicio sea m\u00e1s largo y complicado de lo deseado, en lugar de permitirles centrarse directamente en el desarrollo de sus aplicaciones.</p>"},{"location":"new-project/#dependencias","title":"Dependencias","text":""},{"location":"new-project/#frameworks-nextjs","title":"Frameworks: Next.js","text":"<p>Aunque es posible agregar React a un proyecto existente o crear una aplicaci\u00f3n desde cero, la documentaci\u00f3n oficial de React aconseja considerar el uso de un framework como Next.js para proyectos web m\u00e1s grandes. Esto se debe a que los frameworks proporcionan una estructura y herramientas adicionales que facilitan el desarrollo, el enrutamiento y la optimizaci\u00f3n del rendimiento de la aplicaci\u00f3n.</p> <p>En este curso, seguiremos el consejo de la documentaci\u00f3n oficial y utilizaremos Next.js como nuestro framework principal para proyectos de React. Next.js simplifica la configuraci\u00f3n inicial, proporciona rutas claras y ofrece una renderizaci\u00f3n del lado del servidor, lo que mejora el rendimiento y la experiencia del usuario.</p>"},{"location":"new-project/#librerias-de-componentes-heroui","title":"Librer\u00edas de componentes: HeroUI","text":"<p>Este curso se enfoca en el desarrollo de aplicaciones React y no en el dise\u00f1o web en s\u00ed. Con el prop\u00f3sito de agilizar el proceso de dise\u00f1o y mantener un aspecto profesional en nuestras aplicaciones, optaremos por utilizar HeroUI como nuestra biblioteca de componentes.</p> <p>HeroUI es una biblioteca de componentes de interfaz de usuario que se encuentra preestilizada y lista para ser utilizada. Una de sus ventajas notables es que est\u00e1 construida sobre Tailwind CSS, un popular framework de dise\u00f1o que simplifica la creaci\u00f3n de interfaces atractivas y responsivas. HeroUI, al aprovechar Tailwind CSS, nos permite personalizar f\u00e1cilmente el aspecto y la sensaci\u00f3n de nuestros componentes sin necesidad de escribir CSS personalizado.</p>"},{"location":"new-project/#herramientas-de-diseno-storybook","title":"Herramientas de dise\u00f1o: Storybook","text":"<p>Storybook es una importante herramienta en el desarrollo de React debido a su capacidad para permitir el desarrollo aislado de componentes, generar documentaci\u00f3n en vivo con historias que muestran usos variados, fomentar la colaboraci\u00f3n entre equipos y detectar errores de manera temprana. Esta herramienta agiliza el proceso de desarrollo al centrarse en componentes individuales, mejora la calidad del c\u00f3digo al prevenir errores antes de la integraci\u00f3n y facilita la comunicaci\u00f3n entre dise\u00f1adores y desarrolladores al proporcionar una representaci\u00f3n visual de los componentes en su estado real, lo que contribuye a una experiencia de usuario m\u00e1s s\u00f3lida.</p>"},{"location":"new-project/#entornos-de-testing-vitest","title":"Entornos de testing: Vitest","text":"<p>Vitest es una herramienta de pruebas moderna y r\u00e1pida que se utiliza en el ecosistema de React, dise\u00f1ada como una alternativa m\u00e1s eficiente a Jest. Proporciona un conjunto de bibliotecas y utilidades espec\u00edficas para la realizaci\u00f3n de pruebas en aplicaciones React. Algunas de las bibliotecas m\u00e1s destacadas incluyen <code>@testing-library/react</code> para interactuar con componentes React y <code>@testing-library/jest-dom</code> para realizar afirmaciones sobre su comportamiento y apariencia en un entorno de prueba, aunque es importante notar que, a pesar del nombre <code>jest-dom</code>, es completamente compatible con Vitest gracias a su API compatible con Jest. Vitest es conocido por su alta velocidad y eficiencia. Adem\u00e1s, Vitest facilita la ejecuci\u00f3n de pruebas unitarias y de integraci\u00f3n, ofreciendo caracter\u00edsticas como la ejecuci\u00f3n en paralelo y la recopilaci\u00f3n de cobertura de c\u00f3digo, lo que lo convierte en una excelente opci\u00f3n para el desarrollo y la garant\u00eda de calidad de aplicaciones React.</p>"},{"location":"security-auth/","title":"Configurar Better Auth","text":""},{"location":"security-auth/#autenticacion-con-better-auth","title":"Autenticaci\u00f3n con Better Auth","text":"<p>En esta secci\u00f3n configuraremos Better Auth paso a paso utilizando GitHub como proveedor de autenticaci\u00f3n y una base de datos SQLite local para almacenar las credenciales.</p>"},{"location":"security-auth/#instalacion","title":"Instalaci\u00f3n","text":"<p>Instalamos las dependencias necesarias en el proyecto:</p> <pre><code>npm install better-auth better-sqlite3\nnpm install --save-dev @types/better-sqlite3\n</code></pre> <p>Vamos a usar SQLite con <code>better-sqlite3</code> porque es simple y no requiere instalar servidores adicionales. Si prefieres otro motor, puedes sustituirlo siguiendo la documentaci\u00f3n oficial.</p>"},{"location":"security-auth/#variables-de-entorno","title":"Variables de entorno","text":"<p>Creamos (o actualizamos) el archivo <code>.env.local</code> con los valores que demanda Better Auth. La clave secreta se usa para encriptar y firmar cookies. Puedes generar una cadena aleatoria con cualquier herramienta (por ejemplo <code>openssl rand -base64 32</code>).</p> .env.local<pre><code>BETTER_AUTH_SECRET=pon_aqui_una_cadena_unica\nBETTER_AUTH_URL=http://localhost:3000\nNEXT_PUBLIC_APP_URL=http://localhost:3000\nGITHUB_CLIENT_ID=tu_client_id_de_github\nGITHUB_CLIENT_SECRET=tu_client_secret_de_github\n</code></pre> <p><code>NEXT_PUBLIC_APP_URL</code> lo utilizamos en el cliente para construir la URL base cuando el proyecto se despliega en otro dominio.</p> <p>El campo <code>BETTER_AUTH_URL</code> siempre debe apuntar a la URL p\u00fablica de la aplicaci\u00f3n (en local usaremos <code>http://localhost:3000</code>).</p>"},{"location":"security-auth/#configurar-better-auth","title":"Configurar Better Auth","text":"<p>Creamos el archivo <code>src/lib/auth.ts</code> con la instancia de Better Auth. En este ejemplo habilitamos el plugin <code>nextCookies</code> para que las cookies se sincronicen autom\u00e1ticamente en server actions y server components, configuramos SQLite y registramos el proveedor de GitHub.</p> src/lib/auth.ts<pre><code>import { betterAuth } from 'better-auth'\nimport { nextCookies } from 'better-auth/next-js'\nimport Database from 'better-sqlite3'\n\nexport const auth = betterAuth({\n  database: new Database('./better-auth.sqlite'),\n  plugins: [nextCookies()],\n  socialProviders: {\n    github: {\n      clientId: process.env.GITHUB_CLIENT_ID as string,\n      clientSecret: process.env.GITHUB_CLIENT_SECRET as string,\n    },\n  },\n})\n</code></pre> <p>La base de datos SQLite (<code>better-auth.sqlite</code>) se crea autom\u00e1ticamente en la ra\u00edz del proyecto cuando ejecutemos las migraciones.</p>"},{"location":"security-auth/#crear-las-tablas","title":"Crear las tablas","text":"<p>Better Auth incluye una CLI que genera el esquema y las migraciones necesarias. Desde la ra\u00edz del proyecto ejecutamos:</p> <pre><code>npx @better-auth/cli generate\nnpx @better-auth/cli migrate\n</code></pre> <p>El primer comando crea la migraci\u00f3n y el segundo la aplica sobre nuestro archivo SQLite. Si utilizas otro motor o un ORM, revisa la documentaci\u00f3n oficial para adaptar estos pasos.</p>"},{"location":"security-auth/#ruta-de-api","title":"Ruta de API","text":"<p>Next.js necesita exponer un endpoint que procese las peticiones de autenticaci\u00f3n. Creamos el archivo <code>src/app/api/auth/[...all]/route.ts</code> con el manejador oficial:</p> src/app/api/auth/[...all]/route.ts<pre><code>import { toNextJsHandler } from 'better-auth/next-js'\nimport { auth } from '@/lib/auth'\n\nexport const { GET, POST } = toNextJsHandler(auth.handler)\n</code></pre> <p>Recomendamos mantener la ruta <code>/api/auth/[...all]</code>, ya que coincidimos con lo que espera la librer\u00eda y con la configuraci\u00f3n de GitHub.</p>"},{"location":"security-auth/#registrar-la-aplicacion-en-github","title":"Registrar la aplicaci\u00f3n en GitHub","text":"<p>Para permitir el login social necesitamos crear una OAuth App en GitHub:</p> <ol> <li> <p>Accedemos a https://github.com/settings/developers.</p> </li> <li> <p>Creamos una OAuth App con los siguientes valores en desarrollo:</p> <ol> <li>Homepage URL: <code>http://localhost:3000</code></li> <li>Authorization callback URL: <code>http://localhost:3000/api/auth/callback/github</code></li> </ol> <p></p> </li> <li> <p>Tras completar el formulario, GitHub nos mostrar\u00e1 el <code>Client ID</code>. Desde la misma pantalla generamos un nuevo <code>Client Secret</code>.</p> <p></p> </li> <li> <p>Copiamos ambos valores en <code>.env.local</code>.</p> </li> </ol> <p>Info</p> <p>Si recibes errores relacionados con el correo electr\u00f3nico del usuario, revisa que tu GitHub App tenga el permiso Email addresses en modo lectura dentro de Account permissions.</p>"},{"location":"security-auth/#cliente-de-better-auth-en-react","title":"Cliente de Better Auth en React","text":"<p>El cliente nos ayuda a iniciar sesi\u00f3n desde componentes de React y a recuperar la sesi\u00f3n desde el navegador. Creamos <code>src/lib/auth-client.ts</code>:</p> src/lib/auth-client.ts<pre><code>'use client'\n\nimport { createAuthClient } from 'better-auth/react'\n\nexport const authClient = createAuthClient({\n  baseURL: process.env.NEXT_PUBLIC_APP_URL ?? 'http://localhost:3000',\n})\n\nexport const { signIn, signOut, useSession } = authClient\n</code></pre> <p>Exportamos los m\u00e9todos que utilizaremos en los componentes (<code>signIn</code>, <code>signOut</code>, <code>useSession</code>). Puedes a\u00f1adir m\u00e1s helpers si los necesitas.</p>"},{"location":"security-auth/#proteger-paginas-y-obtener-la-sesion","title":"Proteger p\u00e1ginas y obtener la sesi\u00f3n","text":"<p>Better Auth expone un API preparado para ejecutarse en componentes de servidor o server actions. En este ejemplo recuperamos la sesi\u00f3n dentro de una p\u00e1gina del directorio <code>app</code> y redirigimos a los usuarios no autenticados:</p> src/app/dashboard/page.tsx<pre><code>import { headers } from 'next/headers'\nimport { redirect } from 'next/navigation'\nimport { auth } from '@/lib/auth'\n\nexport default async function DashboardPage() {\n  const session = await auth.api.getSession({\n    headers: await headers(),\n  })\n\n  if (!session) {\n    redirect('/sign-in')\n  }\n\n  return &lt;h1&gt;Hola, {session.user.name ?? 'Usuario'}.&lt;/h1&gt;\n}\n</code></pre>"},{"location":"security-auth/#sign-in-desde-el-cliente","title":"Sign in desde el cliente","text":"<p>En el lado del cliente podemos llamar a <code>signIn.social</code> para abrir la ventana de GitHub. Crea, por ejemplo, un componente <code>LoginButton</code>:</p> src/components/login-button.tsx<pre><code>'use client'\n\nimport { CommandLineIcon } from '@heroicons/react/24/solid'\nimport { Button } from '@heroui/react'\n\nimport { signIn } from '@/lib/auth-client'\n\nexport function LoginButton() {\n  return (\n    &lt;Button\n      color=\"primary\"\n      onPress={() =&gt;\n        signIn.social({ provider: 'github', callbackURL: '/dashboard' })\n      }\n      startContent={&lt;CommandLineIcon className=\"h-5 w-5\" /&gt;}\n      variant=\"solid\"\n    &gt;\n      Entrar con GitHub\n    &lt;/Button&gt;\n  )\n}\n</code></pre> <p>El cliente gestiona la apertura del flujo OAuth y, tras regresar de GitHub, refresca la sesi\u00f3n autom\u00e1ticamente.</p>"},{"location":"security-auth/#pagina-de-inicio-de-sesion","title":"P\u00e1gina de inicio de sesi\u00f3n","text":"<p>Cuando redirigimos a <code>/sign-in</code> necesitamos una vista sencilla que invite al usuario a iniciar sesi\u00f3n con GitHub. Usaremos componentes de HeroUI y un icono de Heroicons para mantener la est\u00e9tica del curso. Crea el archivo <code>src/app/sign-in/page.tsx</code> con el siguiente contenido:</p> src/app/sign-in/page.tsx<pre><code>import { LockClosedIcon } from '@heroicons/react/24/solid'\nimport { Card, CardBody, CardHeader } from '@heroui/react'\n\nimport { LoginButton } from '@/components/login-button'\n\nexport default function SignInPage() {\n  return (\n    &lt;div className=\"flex min-h-screen items-center justify-center bg-default-100\"&gt;\n      &lt;Card className=\"w-[320px]\"&gt;\n        &lt;CardHeader className=\"flex flex-col items-center gap-2 text-center\"&gt;\n          &lt;LockClosedIcon className=\"h-8 w-8 text-primary\" /&gt;\n          &lt;h1 className=\"font-semibold text-large\"&gt;Necesitas iniciar sesi\u00f3n&lt;/h1&gt;\n        &lt;/CardHeader&gt;\n        &lt;CardBody className=\"flex flex-col gap-4 text-center\"&gt;\n          &lt;p className=\"text-default-500 text-sm\"&gt;\n            Usa tu cuenta de GitHub para continuar.\n          &lt;/p&gt;\n          &lt;LoginButton /&gt;\n        &lt;/CardBody&gt;\n      &lt;/Card&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Esta p\u00e1gina funciona como destino tanto para los usuarios que llegan de forma directa como para los que han sido redirigidos por el middleware. Al reutilizar <code>LoginButton</code> mantenemos la l\u00f3gica en un \u00fanico sitio.</p>"},{"location":"security-auth/#middleware-opcional","title":"Middleware opcional","text":"<p>Si necesitas redirigir r\u00e1pidamente desde el <code>middleware</code> de Next.js, puedes comprobar la existencia de la cookie de sesi\u00f3n utilizando el helper <code>getSessionCookie</code>. Ten en cuenta que esta verificaci\u00f3n es optimista: siempre valida la sesi\u00f3n en el servidor antes de mostrar datos sensibles.</p> src/middleware.ts<pre><code>import { NextRequest, NextResponse } from 'next/server'\nimport { getSessionCookie } from 'better-auth/cookies'\n\nexport function middleware(request: NextRequest) {\n  const sessionCookie = getSessionCookie(request)\n\n  if (!sessionCookie) {\n    return NextResponse.redirect(new URL('/sign-in', request.url))\n  }\n\n  return NextResponse.next()\n}\n\nexport const config = {\n  matcher: ['/dashboard'],\n}\n</code></pre>"},{"location":"security-auth/#validacion-completa-en-cada-pagina","title":"Validaci\u00f3n completa en cada p\u00e1gina","text":"<p>La forma segura de proteger rutas es verificar la sesi\u00f3n dentro de la propia p\u00e1gina o en la acci\u00f3n del servidor que vaya a ejecutar l\u00f3gica sensible (como hicimos en el ejemplo anterior con <code>auth.api.getSession</code>).</p>"},{"location":"security-auth/#resumen","title":"Resumen","text":"<ol> <li>Instalamos <code>better-auth</code> y configuramos una base de datos (en este curso usamos SQLite).</li> <li>Creamos un archivo <code>auth.ts</code> con la instancia, habilitamos GitHub como proveedor social y registramos el plugin <code>nextCookies</code>.</li> <li>Configuramos la ruta <code>/api/auth/[...all]</code> con <code>toNextJsHandler</code>.</li> <li>Registramos la aplicaci\u00f3n en GitHub y a\u00f1adimos las credenciales en <code>.env.local</code>.</li> <li>Creamos un cliente (<code>auth-client.ts</code>) para iniciar sesi\u00f3n desde componentes.</li> <li>A\u00f1adimos la p\u00e1gina <code>/sign-in</code> reutilizando <code>LoginButton</code> para ofrecer el acceso social.</li> <li>Protegemos p\u00e1ginas recuperando la sesi\u00f3n con <code>auth.api.getSession</code>.</li> </ol> <p>Con estos pasos ya tenemos autenticaci\u00f3n social con GitHub funcionando en nuestro proyecto Next.js usando Better Auth.</p>"},{"location":"security/","title":"Conceptos b\u00e1sicos","text":"<p>La seguridad en aplicaciones web es esencial para proteger la informaci\u00f3n confidencial y garantizar la privacidad de los usuarios. Al trabajar con Next.js y React, es fundamental tener en cuenta aspectos clave de seguridad, como el manejo de cookies y tokens JWT.</p>"},{"location":"security/#cookies","title":"Cookies","text":"<p>Las cookies son peque\u00f1os archivos de texto que se almacenan en el navegador del usuario. En el contexto de aplicaciones web, las cookies se utilizan para almacenar informaci\u00f3n, como sesiones de usuario. En el caso de Next.js y React, las cookies pueden ser empleadas para gestionar la autenticaci\u00f3n y la autorizaci\u00f3n de usuarios. Es importante asegurarse de que las cookies se utilicen de manera segura y se protejan contra ataques como la manipulaci\u00f3n de cookies o el acceso no autorizado.</p>"},{"location":"security/#tokens-jwt-json-web-tokens","title":"Tokens JWT (JSON Web Tokens)","text":"<p>Los tokens JWT son una forma com\u00fan de autenticaci\u00f3n y autorizaci\u00f3n en aplicaciones web. Estos tokens son emitidos por un servidor de autenticaci\u00f3n y contienen informaci\u00f3n codificada, como los roles del usuario o la fecha de expiraci\u00f3n. En una aplicaci\u00f3n Next.js y React, los tokens JWT se pueden utilizar para verificar la identidad de los usuarios y permitirles acceder a recursos protegidos. Es crucial implementar pr\u00e1cticas s\u00f3lidas para la generaci\u00f3n, gesti\u00f3n y validaci\u00f3n de tokens JWT, adem\u00e1s de asegurarse de que se transmitan de manera segura entre el cliente y el servidor.</p> <p>Mantener un enfoque en la seguridad de las aplicaciones es fundamental para garantizar la confidencialidad y la integridad de los datos. Tanto el uso de cookies como de tokens JWT son herramientas esenciales en la construcci\u00f3n de aplicaciones seguras con Next.js y React.</p>"},{"location":"state-context/","title":"Context API","text":"<p>En esta secci\u00f3n, exploraremos c\u00f3mo utilizar la Context API de React para pasar datos de manera eficiente a trav\u00e9s de m\u00faltiples componentes en una aplicaci\u00f3n. La Context API es una herramienta poderosa que nos permite compartir datos a nivel global en nuestra aplicaci\u00f3n, evitando la necesidad de pasar propiedades manualmente a trav\u00e9s de componentes intermedios. Descubriremos c\u00f3mo crear y consumir contextos, lo que nos permitir\u00e1 simplificar la comunicaci\u00f3n entre componentes y mejorar la mantenibilidad de nuestro c\u00f3digo React.</p> <p>Un contexto en React consta generalmente de tres partes clave:</p> <ol> <li> <p>Proveedor de Contexto (Context Provider): Este componente es responsable de proporcionar los datos y las funciones que deseas compartir a lo largo de la aplicaci\u00f3n. En este caso, el proveedor de contexto contendr\u00e1 el valor del contador y las dos funciones asociadas (resetear y aumentar).</p> </li> <li> <p>Consumidor de Contexto (Context Consumer): Los componentes que deseen acceder a los datos almacenados en el contexto deben consumirlo. El consumidor es responsable de acceder y utilizar los datos proporcionados por el proveedor de contexto.</p> </li> <li> <p>Contexto en s\u00ed (Context): El contexto en s\u00ed mismo es el objeto que contiene los datos y las funciones que se comparten entre componentes. Es la pieza central que conecta al proveedor y al consumidor.</p> </li> </ol>"},{"location":"state-context/#contexto-basico","title":"Contexto b\u00e1sico","text":"<p>En este archivo, se utiliza la funci\u00f3n <code>createContext</code> de React para crear el contexto. Se crea un contexto llamado <code>CounterStateContext</code> que inicialmente se establece como <code>undefined</code>. Este contexto actuar\u00e1 como un contenedor para los datos y las funciones relacionadas con el contador:</p> <p>Tambi\u00e9n define los tipos de datos relacionados con el contexto del contador. Define una interfaz <code>CounterState</code> que incluye un campo <code>counter</code> que representa el valor del contador y una funci\u00f3n <code>setCounter</code> que se utiliza para actualizar ese valor. El componente <code>CounterProvider</code> es el proveedor de contexto. Utiliza el hook <code>useState</code> para crear y mantener el estado del contador, con un valor inicial de 0. Luego, utiliza el contexto <code>CounterStateContext.Provider</code> para proporcionar el valor del contador y la funci\u00f3n <code>setCounter</code> a cualquier componente descendiente que consuma este contexto.</p> src/state/counter-provider/counter-provider.tsx<pre><code>import { useState } from 'react'\nimport { createContext } from 'react'\n\ninterface CounterState {\n  counter: number\n  setCounter: (value: number) =&gt; void\n}\n\nexport const CounterStateContext = createContext&lt;CounterState | undefined&gt;(\n  undefined\n)\n\nexport function CounterProvider({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const [counter, setCounter] = useState(0)\n\n  return (\n    &lt;CounterStateContext.Provider value={{ counter, setCounter }}&gt;\n      {children}\n    &lt;/CounterStateContext.Provider&gt;\n  )\n}\n</code></pre> <p>Warning</p> <p>Nuestro <code>CounterProvider</code> va a compartir tanto el estado (counter) como la funci\u00f3n que lo modifica (setCounter). Si bien esta implementaci\u00f3n puede ser adecuada en situaciones simples, puede no ser \u00f3ptima en casos m\u00e1s complejos.</p> <p>Cuando se utiliza un contexto para compartir tanto el estado como la funci\u00f3n de modificaci\u00f3n, cualquier cambio en el estado (incluso si no se modifica) causar\u00e1 que todos los componentes que consumen ese contexto se vuelvan a renderizar. Al separar el estado y la funci\u00f3n de modificaci\u00f3n en dos contextos diferentes, puedes evitar re-renders innecesarios y mejorar el rendimiento.</p> <p>Por el momento lo haremos as\u00ed y en la secci\u00f3n siguiente los separaremos.</p> <p>Este archivo contiene un hook personalizado llamado useCounter. Este hook se utiliza para consumir el contexto <code>CounterStateContext</code> y proporciona una interfaz para acceder al valor del contador y las funciones de incremento y reinicio. Si se utiliza fuera del contexto del proveedor, arrojar\u00e1 un error para asegurarse de que se utilice correctamente.</p> src/state/counter-provider/use-counter.ts<pre><code>import { useCallback, useContext } from 'react'\n\nimport { CounterStateContext } from './counter-provider'\n\nexport const useCounter = () =&gt; {\n  const state = useContext(CounterStateContext)\n\n  if (state === undefined) {\n    throw new Error('useCounter must be used within a CounterProvider')\n  }\n\n  const { counter, setCounter } = state\n\n  const onIncrement = useCallback(\n    (amount: number) =&gt; setCounter(counter + amount),\n    [counter, setCounter],\n  )\n\n  const onReset = useCallback(() =&gt; setCounter(0), [setCounter])\n\n  return {\n    counter,\n    onIncrement,\n    onReset,\n  }\n}\n</code></pre>"},{"location":"state-context/#carga-del-contexto","title":"Carga del contexto","text":"<p>Necesitamos utilizar el contexto, lo podemos hacer en el <code>src/app/providers.tsx</code> si queremos que sea com\u00fan a toda la aplicaci\u00f3n o podemos usarlo en una p\u00e1gina. Es lo que vamos a hacer. Actualizamos el fichero <code>src/app/counter/layout.tsx</code>.</p> src/app/counter/layout.tsx<pre><code>'use client'\n\nimport { Menu } from '@/components/menu/menu'\nimport { CounterProvider } from '@/state/counter-provider/counter-provider'\n\nexport default function CounterLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    &lt;CounterProvider&gt;\n      &lt;div className=\"container mx-auto\"&gt;\n        &lt;div className=\"flex flex-col gap-2\"&gt;\n          &lt;Menu /&gt;\n          &lt;div&gt;{children}&lt;/div&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/CounterProvider&gt;\n  )\n}\n</code></pre>"},{"location":"state-context/#uso-del-custom-hook","title":"Uso del custom hook","text":"<p>Ahora tenemos un custom hook que podemos usar como usabamos <code>useState</code>. Vamos a cambiar el componente <code>StatelessCounterContainer</code> para que use el contexto en vez de crear el mismo el estado.</p> src/components/counter/stateless-counter-container.tsx<pre><code>'use client'\n\nimport { useCounter } from '@/state/counter-provider/use-counter'\nimport { StatelessCounter } from './stateless-counter'\n\nexport function StatelessCounterContainer() {\n  const { counter, onIncrement, onReset } = useCounter()\n\n  return (\n    &lt;div className=\"flex flex-row gap-2\"&gt;\n      &lt;StatelessCounter\n        counter={counter}\n        id={1}\n        onIncrement={onIncrement}\n        onReset={onReset}\n        step={1}\n      /&gt;\n      &lt;StatelessCounter\n        counter={counter}\n        id={2}\n        onIncrement={onIncrement}\n        onReset={onReset}\n        step={2}\n      /&gt;\n      &lt;StatelessCounter\n        counter={counter}\n        id={3}\n        onIncrement={onIncrement}\n        onReset={onReset}\n        step={5}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Ejercicio</p> <p>Puedes crear un nuevo componente ContextCounter que use internamente <code>useCounter</code> como el original usaba <code>useState</code>. Ser\u00eda similar a nuestro primer componente Counter, de hecho usar\u00eda el mismo contrato:</p> src/components/counter/context-counter.ts<pre><code>interface CounterProperties {\n  id: number\n  step: number\n}\n</code></pre> <p>Si ahora recargamos la p\u00e1gina, vemos que la segunda fila sigue comport\u00e1ndose igual que antes, compartiendo el estado. Solo que ahora se almacena en el contexto y no dentro del contenedor.</p>"},{"location":"state-context/#conclusion","title":"Conclusi\u00f3n","text":"<p>Por el momento hemos visto tres formas distintas de manejar estados, dependiendo de nuestras necesidades usaremos uno u otro. Debemos intentar usar siempre el m\u00e1s sencillo. Si el estado no se necesita compartir masivamente no es necesario crear un contexto.</p>"},{"location":"state-external/","title":"Componentes sin estado","text":"<p>Vamos a imaginar un nuevo caso de uso donde queramos compartir el mismo estado entre diferentes componentes. En este caso, lo que interesa es que nuestros componentes sean sin estado (stateless). En el caso de nuestro contador eso significa que al no poder usar hooks, tanto <code>counter</code> como <code>setCounter</code> viven fuera de nuestro componente y tanto el valor como los handlers vienen dados como argumentos.</p> <p>Info</p> <p>Recuerda que esto no son casos reales, solo ejemplos de c\u00f3mo aplicar distintos patrones.</p> <p>Para ello vamos a crear un nuevo componente llamado <code>StatelessCounter</code> para evitar perder el trabajo que ten\u00edamos hecho.</p>"},{"location":"state-external/#componente-statelesscounter","title":"Componente StatelessCounter","text":"<p>Ahora nuestro componente tiene m\u00e1s propiedades, a las que ya ten\u00eda <code>Counter</code> tenemos que pasarle el valor actual del contador, una funci\u00f3n que se llamar\u00e1 para indicar que queremos resetear el contador, y otra para indicar que queremos cambiar en un valor dado el contador.</p> <pre><code>interface StatelessCounterProperties {\n  id: number\n  step: number\n  counter: number\n  onIncrement: (amount: number) =&gt; void\n  onReset: () =&gt; void\n}\n</code></pre> <p>Este ser\u00eda el componente completo, si te fijas, hemos cambiado <code>setCounter</code> por nuestras funciones:</p> src/components/counter/stateless-counter.tsx<pre><code>'use client'\n\nimport {\n  ArrowPathIcon,\n  ChevronDoubleLeftIcon,\n  ChevronDoubleRightIcon,\n  ChevronLeftIcon,\n  ChevronRightIcon,\n} from '@heroicons/react/24/outline'\nimport {\n  Button,\n  ButtonGroup,\n  Card,\n  CardFooter,\n  CardHeader,\n} from '@heroui/react'\n\ninterface StatelessCounterProperties {\n  counter: number\n  id: number\n  onIncrement: (amount: number) =&gt; void\n  onReset: () =&gt; void\n  step: number\n}\n\nexport function StatelessCounter({\n  counter,\n  id,\n  onIncrement,\n  onReset,\n  step,\n}: StatelessCounterProperties) {\n  return (\n    &lt;Card className=\"w-60 bg-linear-to-br from-violet-500 to-fuchsia-500\"&gt;\n      &lt;CardHeader className=\"items-start! flex-col\"&gt;\n        &lt;div className=\"flex flex-col\"&gt;\n          &lt;p className=\"font-bold text-tiny text-white/60 uppercase\"&gt;\n            Contador #{id}\n          &lt;/p&gt;\n          &lt;p className=\"font-medium text-large text-white\"&gt;\n            El contador vale {counter}.\n          &lt;/p&gt;\n        &lt;/div&gt;\n      &lt;/CardHeader&gt;\n      &lt;CardFooter className=\"justify-center\"&gt;\n        &lt;ButtonGroup&gt;\n          &lt;Button\n            aria-label=\"Decrement counter with step\"\n            isIconOnly\n            onPress={() =&gt; onIncrement(-step * 10)}\n            size=\"md\"\n          &gt;\n            &lt;ChevronDoubleLeftIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              -{step * 10}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            aria-label=\"Decrement counter\"\n            isIconOnly\n            onPress={() =&gt; onIncrement(-step)}\n            size=\"md\"\n          &gt;\n            &lt;ChevronLeftIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              -{step}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            aria-label=\"Reset counter\"\n            isIconOnly\n            onPress={onReset}\n            size=\"md\"\n          &gt;\n            &lt;ArrowPathIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            aria-label=\"Increment counter\"\n            isIconOnly\n            onPress={() =&gt; onIncrement(step)}\n            size=\"md\"\n          &gt;\n            &lt;ChevronRightIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              +{step}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n          &lt;Button\n            aria-label=\"Increment counter with step\"\n            isIconOnly\n            onPress={() =&gt; onIncrement(step * 10)}\n            size=\"md\"\n          &gt;\n            &lt;ChevronDoubleRightIcon\n              className=\"text-gray-600 dark:text-gray-400\"\n              height=\"1.3rem\"\n            /&gt;\n            &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n              +{step * 10}\n            &lt;/div&gt;\n          &lt;/Button&gt;\n        &lt;/ButtonGroup&gt;\n      &lt;/CardFooter&gt;\n    &lt;/Card&gt;\n  )\n}\n</code></pre> <p>Y por \u00faltimo la historia:</p> src/stories/components/stateless-counter.stories.ts<pre><code>import type { Meta, StoryObj } from '@storybook/nextjs'\nimport { fn } from 'storybook/test'\nimport { StatelessCounter } from '@/components/counter/stateless-counter'\n\nconst meta = {\n  component: StatelessCounter,\n  parameters: {\n    layout: 'centered',\n  },\n  title: 'Components/StatelessCounter',\n  args: {\n    onIncrement: fn(),\n    onReset: fn(),\n  },\n} satisfies Meta&lt;typeof StatelessCounter&gt;\n\nexport default meta\ntype Story = StoryObj&lt;typeof meta&gt;\n\nexport const Basic: Story = {\n  args: {\n    counter: 0,\n    id: 1,\n    step: 1,\n  },\n}\n</code></pre> <p>Si nos vamos al panel de Storybook, ahora veremos que el contador como tal no funciona, obvio porque no tiene estado. Sin embargo si pulsamos alg\u00fan bot\u00f3n veremos que la pesta\u00f1a actions refleja las acciones que se ejecutan en el handler:</p> <p></p>"},{"location":"state-external/#pasar-el-estado-entre-componentes","title":"Pasar el estado entre componentes","text":"<p>Ahora ya podemos crear el estado del contador y pasarlo como argumento. Pero no es buena idea que el estado est\u00e9 en la propia <code>CounterPage</code>, porque en la nueva versi\u00f3n de Next perder\u00edamos la propiedad de que esa p\u00e1gina fuera un Server React Component.</p> <p>Es mejor crear un componente que contenga a nuestros contadores sin estado:</p> src/components/counter/stateless-counter-container.tsx<pre><code>'use client'\n\nimport { useCallback, useState } from 'react'\n\nimport { StatelessCounter } from './stateless-counter'\n\nexport function StatelessCounterContainer() {\n  const [counter, setCounter] = useState(0)\n\n  const onIncrement = useCallback(\n    (amount: number) =&gt; setCounter(counter + amount),\n    [counter]\n  )\n\n  const onReset = useCallback(() =&gt; setCounter(0), [])\n\n  return (\n    &lt;div className=\"flex flex-row gap-2\"&gt;\n      &lt;StatelessCounter\n        counter={counter}\n        id={1}\n        onIncrement={onIncrement}\n        onReset={onReset}\n        step={1}\n      /&gt;\n      &lt;StatelessCounter\n        counter={counter}\n        id={2}\n        onIncrement={onIncrement}\n        onReset={onReset}\n        step={2}\n      /&gt;\n      &lt;StatelessCounter\n        counter={counter}\n        id={3}\n        onIncrement={onIncrement}\n        onReset={onReset}\n        step={5}\n      /&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Y a\u00f1adimos el componente a nuestra p\u00e1gina:</p> src/app/counter/page.tsx<pre><code>import { CounterContainer } from '@/components/counter/counter-container'\nimport { StatelessCounterContainer } from '@/components/counter/stateless-counter-container'\n\nexport default function CounterPage() {\n  return (\n    &lt;div className=\"flex flex-col gap-2\"&gt;\n      &lt;h2&gt;State Counters&lt;/h2&gt;\n      &lt;div className=\"flex flex-row gap-2\"&gt;\n        &lt;CounterContainer /&gt;\n      &lt;/div&gt;\n      &lt;h2&gt;Stateless Counters&lt;/h2&gt;\n      &lt;div className=\"flex flex-row gap-2\"&gt;\n        &lt;StatelessCounterContainer /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"state-external/#conclusion","title":"Conclusi\u00f3n","text":"<p>Ahora podemos ver dos filas de componentes, la primera no comporten estado y la segunda s\u00ed. Usar una u otra depender\u00e1 de nuestro caso de uso. Por lo general no habr\u00e1 muchas situaciones en las que tengamos que crear componentes sin estado.</p> <p></p> <p>Para aquellos casos en los que necesitemos compartirlo, veremos que probablemente lo necesitemos en distintos puntos del documento que no est\u00e9n pr\u00f3ximos entre s\u00ed. Si ese fuera el caso, o se usa composici\u00f3n si es posible, o necesitamos usar contextos, que veremos en la siguiente secci\u00f3n.</p>"},{"location":"state-internal/","title":"Componentes con estado","text":""},{"location":"state-internal/#gestionar-el-estado-dentro-del-componente","title":"Gestionar el estado dentro del componente","text":"<p>El hook <code>useState</code> en React permite gestionar el estado local de un componente funcional. Al utilizar <code>useState</code>, podemos declarar variables de estado y realizar actualizaciones en respuesta a eventos o acciones del usuario. El hook consta de dos partes: el valor actual del estado y una funci\u00f3n para actualizar ese valor. Cuando llamamos a la funci\u00f3n de actualizaci\u00f3n, React re-renderiza el componente con el nuevo estado, lo que proporciona una experiencia din\u00e1mica y reactiva en nuestras aplicaciones. En esta secci\u00f3n, exploraremos c\u00f3mo utilizar <code>useState</code> para mantener y actualizar el estado interno de nuestros componentes de manera efectiva.</p> <p><code>useState</code> acepta dos tipos de inicializaci\u00f3n. La forma m\u00e1s habitual es pasar directamente el valor inicial:</p> <pre><code>const [counter, setCounter] = useState(0)\n</code></pre> <p>Inicializaci\u00f3n perezosa</p> <p>Si el c\u00e1lculo del estado inicial necesita m\u00e1s l\u00f3gica (por ejemplo, leer del <code>localStorage</code> o procesar datos), podemos pasar una funci\u00f3n que devuelva ese valor. React solo ejecuta esa funci\u00f3n la primera vez que monta el componente, evitando trabajo extra en cada renderizado.</p> <pre><code>const [counter, setCounter] = useState(() =&gt; {\n  const stored = window.localStorage.getItem('counter')\n  return stored ? Number(stored) : 0\n})\n</code></pre> <p>Usa esta variante m\u00e1s avanzada cuando el valor inicial depende de operaciones costosas o de efectos secundarios. As\u00ed mantienes el componente ligero en renderizados posteriores.</p> <p>La funci\u00f3n de actualizaci\u00f3n que devuelve <code>useState</code> tambi\u00e9n admite dos formas de uso. Podemos pasar el valor final directamente o proporcionar una funci\u00f3n que reciba el estado anterior y devuelva el nuevo.</p> <p>Usa <code>setCounter(nuevoValor)</code> cuando el resultado es independiente del estado previo. Es la opci\u00f3n ideal para resets como <code>setCounter(0)</code> o para establecer flags booleanos.</p> <p>Asignaci\u00f3n directa</p> <pre><code>const [counter, setCounter] = useState(0)\nsetCounter(1)\n</code></pre> <p>Si el nuevo valor depende del existente, pasa una funci\u00f3n: <code>setCounter(previous =&gt; previous + step)</code>. React ejecuta esa funci\u00f3n con el estado m\u00e1s reciente, incluso si varios eventos se disparan antes de renderizar de nuevo.</p> <p>Actualizaci\u00f3n derivada</p> <pre><code>const [counter, setCounter] = useState(0)\nsetCounter(previous =&gt; previous + 1)\n</code></pre> <p>Trabajar con la funci\u00f3n evita condiciones de carrera: <code>setCounter(counter + step)</code> reutiliza el valor que estaba disponible en el render anterior, de modo que varios clics r\u00e1pidos podr\u00edan perder incrementos. La variante funcional garantiza que siempre operas sobre el estado vigente. Elegir entre ambas alternativas har\u00e1 que tus componentes se comporten de forma predecible aunque actualices el estado desde distintos manejadores o efectos.</p>"},{"location":"state-internal/#incrementar-el-contador","title":"Incrementar el contador","text":"<p>Los hooks siempre deben aparecer al comienzo de las funciones donde se declaran. Por lo tanto, vamos a reemplazar la variable counter, por el hook <code>useState</code>, el cual nos devolver\u00e1 la variable <code>counter</code> y la funci\u00f3n <code>setCounter</code> que usaremos para cambiar el estado/valor de dicha variable:</p> src/components/counter/counter.tsx<pre><code>import { useState } from 'react'\n\n// ...\n\nexport function Counter({ id, step }: CounterProperties) {\n\n  const [counter, setCounter] = useState(0)\n\n  return (\n    &lt;Card className=\"w-60 bg-linear-to-br from-violet-500 to-fuchsia-500\"&gt;\n</code></pre> <p>Y ahora podemos usar la funci\u00f3n setCounter para actualizar el valor de counter. Por ejemplo modificamos el bot\u00f3n de incrementar el contados a\u00f1adiendo a la  propiedad onPress una funci\u00f3n que al ser ejecutada incremente el valor de counter.</p> src/components/counter/counter.tsx<pre><code>&lt;Button \n  isIconOnly size=\"md\" aria-label=\"Increment counter\"\n  onPress={() =&gt; setCounter(previous =&gt; previous + step)}\n&gt;\n  &lt;ChevronRightIcon\n    className=\"text-gray-600 dark:text-gray-400\"\n    height=\"1.3rem\"\n  /&gt;\n  &lt;div className=\"absolute right-1 bottom-0 font-bold text-[10px]\"&gt;\n    +{step}\n  &lt;/div&gt;\n&lt;/Button&gt;\n</code></pre> <p>Info</p> <p>Es importante entender que los estados son inmutable, o deben tratarse como si lo fueran. Si queremos modificarlos debemos usar siempre la funci\u00f3n set proporcionada. De lo contrario React no sabr\u00e1 que tiene que volver a renderizar el componente.</p> <p>En el manejador de clic usamos la actualizaci\u00f3n derivada descrita en la secci\u00f3n anterior (<code>setCounter(previous =&gt; previous + step)</code>) para asegurarnos de que el incremento se aplica siempre sobre el estado m\u00e1s reciente.</p> <p>Ahora al pulsado el bot\u00f3n de incrementar el contador veremos que ya funciona  correctamente.</p> <p>Ejercicio</p> <p>Completa el resto de acciones de los botones de incrementar y decrementar por pasos y de reiniciar el contador a cero.</p>"},{"location":"state-internal/#componente-countercontainer","title":"Componente CounterContainer","text":"<p>Ahora vamos a crear otro componente para visualizar a la vez a tres contadores</p> src/components/counter/counter-container.tsx<pre><code>import { Counter } from './counter'\n\nexport function CounterContainer() {\n  return (\n    &lt;div className=\"flex flex-row gap-2\"&gt;\n      &lt;Counter id={1} step={1} /&gt;\n      &lt;Counter id={2} step={1} /&gt;\n      &lt;Counter id={3} step={1} /&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"state-internal/#visualizar-el-componente-en-la-aplicacion-next","title":"Visualizar el componente en la aplicaci\u00f3n Next","text":"<p>Hasta ahora hemos usado Storybook para visualizar los componentes, vamos a crear nuestra primera p\u00e1gina para usarlo all\u00ed. </p> <p>Vamos a crear los siguientes archivos.</p>"},{"location":"state-internal/#componente-menu","title":"Componente Menu","text":"src/components/menu/menu.tsx<pre><code>'use client'\n\nimport { Navbar, NavbarBrand, NavbarContent } from '@heroui/react'\n\nimport { ThemeSwitcher } from '@/components/theme-switcher'\n\nexport function Menu() {\n  return (\n    &lt;Navbar position=\"static\"&gt;\n      &lt;NavbarBrand&gt;Curso de React&lt;/NavbarBrand&gt;\n      &lt;NavbarContent justify=\"end\"&gt;\n        &lt;ThemeSwitcher /&gt;\n      &lt;/NavbarContent&gt;\n    &lt;/Navbar&gt;\n  )\n}\n</code></pre>"},{"location":"state-internal/#componente-counterlayout","title":"Componente CounterLayout","text":"src/app/counter/layout.tsx<pre><code>'use client'\n\nimport { Menu } from '@/components/menu/menu'\n\nexport default function CounterLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    &lt;div className=\"container mx-auto\"&gt;\n      &lt;div className=\"flex flex-col gap-2\"&gt;\n        &lt;Menu /&gt;\n        &lt;div&gt;{children}&lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre>"},{"location":"state-internal/#componente-counterpage","title":"Componente CounterPage","text":"src/app/counter/page.tsx<pre><code>import { CounterContainer } from '@/components/counter/counter-container'\n\nexport default function CounterPage() {\n  return (\n    &lt;div className=\"flex flex-col gap-2\"&gt;\n      &lt;h2&gt;State Counters&lt;/h2&gt;\n      &lt;div className=\"flex flex-row gap-2\"&gt;\n        &lt;CounterContainer /&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n  )\n}\n</code></pre> <p>Y ahora debes tener disponible una nueva p\u00e1gina <code>/counter</code> con tres contadores en http://localhost:3000/counter y con un men\u00fa.</p> <p></p> <p>Info</p> <p>Los layout reciben un par\u00e1metro children que es la combinaci\u00f3n de todos los layouts de los directorios superiores m\u00e1s la p\u00e1gina superior. Es decir, que lo que se est\u00e1 renderizando es equivalente a:</p> <pre><code>&lt;RootLayout&gt; // Este el layout en src/app/layout.tsx\n  &lt;CounterLayout&gt;\n    &lt;CounterPage /&gt;\n  &lt;/CounterLayout&gt;\n&lt;/RootLayout&gt;\n</code></pre> <p>Es muy \u00fatil para heredar plantillas entre subrutas. M\u00e1s informaci\u00f3n en la documentaci\u00f3n de Next.</p>"},{"location":"state-internal/#conclusion","title":"Conclusi\u00f3n","text":"<p>Si pruebas los tres componentes, ver\u00e1s que cada uno tiene su propio estado y que no se comparten entre ellos. Es decir, si incrementas uno, el resto queda como estaba.</p>"},{"location":"state-reducer/","title":"Uso de reducers","text":"<p>En este cap\u00edtulo, exploraremos una forma m\u00e1s avanzada de gestionar el estado en aplicaciones React utilizando los conceptos de reducers y contextos. Aprenderemos c\u00f3mo los reducers, implementados con React Hooks, pueden ser una herramienta poderosa para administrar estados complejos y realizar actualizaciones controladas. Adem\u00e1s, discutiremos cu\u00e1ndo y por qu\u00e9 es apropiado utilizar reducers en casos de uso espec\u00edficos, lo que te permitir\u00e1 tomar decisiones informadas al dise\u00f1ar la l\u00f3gica de tu aplicaci\u00f3n React.</p> <p>Los reducers son particularmente valiosos en situaciones donde el estado de la aplicaci\u00f3n es complejo y necesita ser actualizado de manera controlada. Ejemplos de estos casos incluyen la gesti\u00f3n de formularios con m\u00faltiples campos interdependientes, la administraci\u00f3n de un carrito de compras en l\u00ednea con numerosos productos y cantidades, o el control de flujos de datos asincr\u00f3nicos en aplicaciones que requieren comunicaci\u00f3n en tiempo real.</p>"},{"location":"state-reducer/#contexto-con-reducers","title":"Contexto con reducers","text":"<p>En el anterior ejemplo, el mismo contexto ten\u00eda el estado y la funci\u00f3n que lo actualiza. En este ejemplo los vamos a separar para que el estado viaje por un contexto y la funci\u00f3n <code>dispatch</code> por otro.</p>"},{"location":"state-reducer/#acciones","title":"Acciones","text":"<p>Este archivo define las constantes <code>INCREMENT</code> y <code>RESET</code>, las dos acciones que mantiene el contador para conservar la misma API que vimos en la secci\u00f3n anterior (<code>onIncrement</code> y <code>onReset</code>). Adem\u00e1s describe los tipos asociados a cada acci\u00f3n y expone los action creators que usaremos desde los componentes.</p> src/state/counter-provider/actions.ts<pre><code>export const INCREMENT = 'counter/increment' as const\nexport const RESET = 'counter/reset' as const\n\ninterface CounterIncrementAction {\n  type: typeof INCREMENT\n  value: number\n}\n\ninterface CounterResetAction {\n  type: typeof RESET\n}\n\nexport type CounterAction = CounterIncrementAction | CounterResetAction\n\nexport const increment = (value: number): CounterIncrementAction =&gt; ({\n  type: INCREMENT,\n  value,\n})\n\nexport const reset = (): CounterResetAction =&gt; ({ type: RESET })\n</code></pre> <p><code>INCREMENT</code> siempre transporta un <code>value: number</code>, el mismo paso (<code>step</code>) que reciben nuestros componentes. <code>RESET</code> no necesita payload porque basta con devolver el estado inicial. Marcamos las constantes con <code>as const</code> para que TypeScript trate esas cadenas como literales exactos, de modo que el reducer pueda discriminar las acciones sin comprobaciones adicionales.</p> <p>En los componentes esto se traduce en llamadas muy legibles:</p> <pre><code>dispatch(increment(5)) // equivale a onIncrement(5)\ndispatch(reset()) // equivale a onReset()\n</code></pre> <p>As\u00ed podemos mantener la interfaz <code>onIncrement</code>/<code>onReset</code> mientras la implementaci\u00f3n interna pasa a Redux-style actions.</p>"},{"location":"state-reducer/#reducer","title":"Reducer","text":"<p>Este archivo define el reducer, que es una funci\u00f3n que toma el estado actual y una acci\u00f3n, y devuelve el nuevo estado. Aqu\u00ed nos encargamos de gestionar c\u00f3mo cambia el contador en respuesta a las acciones <code>INCREMENT</code> y <code>RESET</code>, manteniendo la l\u00f3gica bien localizada y f\u00e1cil de testear. El estado, como en el caso del <code>useState</code>, es inmutable: no debemos modificarlo, solo devolver el nuevo valor. Cuidado cuando se actualicen objetos porque estos se suelen copiar por referencia.</p> <p>src/state/counter-provider/reducer.ts<pre><code>import { type CounterAction, INCREMENT, RESET } from './actions'\n\nexport type CounterState = number\nexport type CounterDispatcher = React.Dispatch&lt;CounterAction&gt;\n\nexport const initialCounterState: CounterState = 0\n\nexport const reducer: React.Reducer&lt;CounterState, CounterAction&gt; = (\n  state,\n  action\n) =&gt; {\n  switch (action.type) {\n    case INCREMENT: {\n      const step = Number(action.value)\n      return state + step\n    }\n\n    case RESET:\n      return initialCounterState\n\n    default:\n      return state\n  }\n}\n</code></pre> Aqu\u00ed se encuentra el hook personalizado <code>useCounter</code>, que utiliza los contextos <code>CounterStateContext</code> y <code>CounterDispatcherContext</code> para acceder al estado del contador y a la funci\u00f3n <code>dispatch</code>. Este hook encapsula la interacci\u00f3n con el contexto y expone la misma interfaz que ten\u00edamos con <code>useState</code>: <code>onIncrement</code> y <code>onReset</code>. As\u00ed los componentes que ya consum\u00edan esas funciones pueden seguir funcionando sin cambios mientras la implementaci\u00f3n interna evoluciona.</p>"},{"location":"state-reducer/#hook","title":"Hook","text":"src/state/counter-provider/use-counter.ts<pre><code>import { useCallback, useContext } from 'react'\nimport { increment, reset } from './actions'\nimport {\n  CounterDispatcherContext,\n  CounterStateContext,\n} from './counter-provider'\n\nexport function useCounter() {\n  const state = useContext(CounterStateContext)\n  const dispatch = useContext(CounterDispatcherContext)\n\n  if (state === undefined || dispatch === undefined) {\n    throw new Error('useCounter must be used within a &lt;CounterProvider&gt;')\n  }\n\n  const incrementCounter = useCallback(\n    (step = 1) =&gt; {\n      dispatch(increment(step))\n    },\n    [dispatch]\n  )\n\n  const resetCounter = useCallback(() =&gt; {\n    dispatch(reset())\n  }, [dispatch])\n\n  return {\n    counter: state,\n    onIncrement: incrementCounter,\n    onReset: resetCounter,\n  }\n}\n</code></pre>"},{"location":"state-reducer/#context-provider","title":"Context provider","text":"<p>Cuando el estado y el dispatcher viajan juntos, cualquier cambio en el valor dispara un re-render en todos los componentes que consumen el contexto, aunque solo necesiten la funci\u00f3n para lanzar acciones. Al separarlos, los componentes que \u00fanicamente despachan acciones no se ven afectados por las variaciones del estado y mantenemos a salvo la interfaz p\u00fablica (<code>onIncrement</code>, <code>onReset</code>) que ya conoc\u00edamos.</p> <p>Este componente es el proveedor de contexto para el contador. Utiliza el reducer definido en <code>reducer.ts</code> para administrar el estado y proporciona los contextos <code>CounterStateContext</code> y <code>CounterDispatcherContext</code> para que los componentes descendientes puedan acceder al valor y a la funci\u00f3n <code>dispatch</code>. Separar ambos contextos evita renderizados innecesarios y nos permite conservar la misma firma externa que en el cap\u00edtulo anterior.</p> src/state/counter-provider/counter-provider.tsx<pre><code>import { createContext, useReducer } from 'react'\nimport {\n  type CounterDispatcher,\n  type CounterState,\n  initialCounterState,\n  reducer,\n} from './reducer'\n\nexport const CounterStateContext = createContext&lt;CounterState | undefined&gt;(\n  undefined\n)\nexport const CounterDispatcherContext = createContext&lt;\n  CounterDispatcher | undefined\n&gt;(undefined)\n\nexport function CounterProvider({ children }: { children: React.ReactNode }) {\n  const [state, dispatch] = useReducer(reducer, initialCounterState)\n\n  return (\n    &lt;CounterStateContext.Provider value={state}&gt;\n      &lt;CounterDispatcherContext.Provider value={dispatch}&gt;\n        {children}\n      &lt;/CounterDispatcherContext.Provider&gt;\n    &lt;/CounterStateContext.Provider&gt;\n  )\n}\n</code></pre>"},{"location":"state-reducer/#cambios","title":"Cambios","text":"<p>\u00bfEn qu\u00e9 cambia el uso de reducers con el <code>useState</code>? B\u00e1sicamente la diferencia radica en que con <code>useState</code> la l\u00f3gica y la representaci\u00f3n est\u00e1n unidas, mientras que ahora el componente <code>StatelessCounterContainer</code> no sabe nada de c\u00f3mo se producen los cambios, solo indica intenciones.</p> <p>Question</p> <ol> <li>Crea una nueva acci\u00f3n llamada DECREMENT y separa los incrementos de los decrementos.</li> <li>Crea un Counter que dentro use el hook <code>useCounter</code> con las tres acciones (incremento, decremento y reinicio). </li> </ol> <p>El objetivo es que los botones llamen a su correspondiente acci\u00f3n de decremento e incremento.</p> <p>Ejemplo:</p> <pre><code>// con useState, el componente tiene que conocer la l\u00f3gica y el estado previo\n&lt;Component onClick={() =&gt; setState(NEW VALUE LOGIC)}&gt;\n\n// con reducers, solo indica la intencion (ACTION) y los argumentos (ARGS)\n// pero no necesita saber el valor del estado porque el reducer que lo ejecuta\n&lt;Component onClick={() =&gt; dispatch({type: ACTION, value: ARGS})}&gt;\n</code></pre> <p>En realidad, podemos decir que con reducers, los componentes lanzan eventos y los reducers act\u00faan como event handlers.</p>"},{"location":"state-reducer/#conclusiones","title":"Conclusiones","text":"<p>El uso de reducers en React, especialmente cuando se trabaja con testing, proporciona varias ventajas significativas:</p> <ol> <li> <p>Previsibilidad: Los reducers se basan en funciones puras que toman un estado actual y una acci\u00f3n para producir un nuevo estado. Esto hace que las actualizaciones de estado sean predecibles y evita efectos secundarios no deseados, lo que facilita la prueba de componentes que utilizan el estado gestionado por reducers. Por eso son ideales para pruebas unitarias.</p> </li> <li> <p>Separaci\u00f3n de responsabilidades: Al dividir la l\u00f3gica de actualizaci\u00f3n del estado en reducers, se logra una clara separaci\u00f3n de responsabilidades en la aplicaci\u00f3n. Esto facilita la prueba a nivel de unidad de los reducers sin la necesidad de interactuar con componentes de la interfaz de usuario.</p> </li> <li> <p>Reducci\u00f3n de Acoplamiento: Al utilizar reducers, reduces el acoplamiento entre componentes y el estado global de la aplicaci\u00f3n. Esto facilita la prueba de componentes de manera aislada sin depender de otros componentes o l\u00f3gica de la aplicaci\u00f3n.</p> </li> </ol> <p>Sin embargo, hay un aumento en la complejidad y en el n\u00famero de ficheros. Solo se debe aplicar en componentes y situaciones complejas, con un estado muy grande.</p>"},{"location":"storybook/","title":"Storybook","text":"<p>Storybook es una herramienta sumamente valiosa en el desarrollo de aplicaciones, ya que permite la visualizaci\u00f3n y exploraci\u00f3n de componentes de forma aislada, lo que significa que puedes ver y probar un componente espec\u00edfico sin tener que ejecutar toda la aplicaci\u00f3n. Esto resulta extremadamente \u00fatil durante el proceso de desarrollo, ya que te permite concentrarte en la construcci\u00f3n y refinamiento de componentes individuales de manera eficiente, sin la necesidad de navegar por la aplicaci\u00f3n en su totalidad.</p> <p>Adem\u00e1s de su capacidad para facilitar el desarrollo y la depuraci\u00f3n de componentes, Storybook es tambi\u00e9n una herramienta clave para la creaci\u00f3n de un \"design system\" o sistema de dise\u00f1o. Un \"design system\" es un conjunto cohesivo de principios de dise\u00f1o, componentes reutilizables y directrices de estilo que garantizan la coherencia visual y de interacci\u00f3n en toda la aplicaci\u00f3n. Storybook es un lugar ideal para compilar y documentar estos componentes y sus variaciones, lo que permite a los dise\u00f1adores y desarrolladores colaborar de manera efectiva para definir y mantener un dise\u00f1o consistente en toda la aplicaci\u00f3n. En resumen, Storybook no solo simplifica el proceso de desarrollo y pruebas, sino que tambi\u00e9n sirve como una herramienta fundamental en la creaci\u00f3n y gesti\u00f3n de un sistema de dise\u00f1o s\u00f3lido y coherente.</p> <p>Sin embargo, no suele ser sencillo de configurar. Aunque la herramienta de instalaci\u00f3n que proporciona suele reconocer el framework, normalmente no es capaz de reconocer los temas que utilizamos o ciertas configuraciones de typescript como las rutas.</p>"},{"location":"storybook/#instalacion","title":"Instalaci\u00f3n","text":"<p>En vez de dirigirnos a la web principal, vamos a indicar los pasos a seguir. Lo primero es instalar storybook dentro de nuestro proyecto. Seleccionaremos la configuraci\u00f3n m\u00ednima.</p> <pre><code>npm create storybook@latest\n</code></pre> <p>Info</p> <p>La primera vez que se instala se inicia solo.</p> <p>Se nos abrir\u00e1 esta p\u00e1gina con algunos componentes de ejemplo:</p> <p></p> <p>Para tener soporte de tema oscuro, necesitamos tambi\u00e9n instalar el siguiente paquete.</p> <p>Warning</p> <p>Para instalar el nuevo plugin, cierra el servicio de storybook que tienes abierto con Ctrl+C, y cuando  termines de configurarlo puedes volver a ejecutar storybook con esta orden:</p> <pre><code>npm run storybook\n</code></pre>"},{"location":"storybook/#creacion-de-una-historia","title":"Creaci\u00f3n de una historia","text":"<p>Una historia en Storybook es una representaci\u00f3n visual y funcional de un componente de React en un estado particular o variaci\u00f3n. Cada historia describe c\u00f3mo se ve y se comporta un componente en un contexto espec\u00edfico, lo que facilita la visualizaci\u00f3n y documentaci\u00f3n de su uso y apariencia.</p> <p>Vamos a crear la historia del componente que creamos antes:</p> src/stories/components/theme-switcher.stories.ts<pre><code>import { Meta, StoryObj } from '@storybook/react'\n\nimport { ThemeSwitcher } from '@/components/theme-switcher/theme-switcher'\n\nconst meta = {\n  component: ThemeSwitcher,\n  parameters: {\n    layout: 'centered',\n  },\n  tags: ['autodocs'],\n  title: 'Components/ThemeSwitcher',\n} satisfies Meta&lt;typeof ThemeSwitcher&gt;\n\nexport default meta\ntype Story = StoryObj&lt;typeof meta&gt;\n\nexport const Basic: Story = {}\n</code></pre> <p>Y aparecer\u00e1 una nueva secci\u00f3n llamada componentes que tendr\u00e1 nuestra historia. Si accedemos a ella veremos que el componente no se ve correctamente. </p>"},{"location":"storybook/#configuracion-de-storybook","title":"Configuraci\u00f3n de Storybook","text":"<p>Storybook es una aplicaci\u00f3n distinta a la de next, por tanto, no tiene por qu\u00e9 cargar la misma configuraci\u00f3n que tenemos en nuestro proyecto. Esta es la parte m\u00e1s complicada de hacer funcionar Storybook.</p> <p>En nuestro caso tenemos dos partes que tenemos que configurar: los estilos de HeroUI y los providers para los estados de los componentes.</p> <p>Primero vamos a cargar los providers a la hora de visualizar los componentes:</p> .storybook/preview.ts<pre><code>import '@/app/globals.css'\n\nimport { withThemeByClassName } from '@storybook/addon-themes'\nimport type { Preview } from '@storybook/react'\n\nconst preview: Preview = {\n  decorators: [\n    withThemeByClassName({\n      themes: {\n        light: 'light',\n        dark: 'dark',\n      },\n      defaultTheme: 'light',\n    }),\n  ],\n  parameters: {\n    controls: {\n      matchers: {\n        color: /(background|color)$/i,\n        date: /Date$/i,\n      },\n    },\n  },\n}\n\nexport default preview\n</code></pre> <p>Ahora veremos nuestra historia de forma correcta. Podemos ya incluso borrar los componentes de ejemplo.</p> <p></p> <p>Ejercicio</p> <p>Guarda los cambios que hemos hecho y la historia que hemos creado en git. Storybook crea una serie de historias de ejemplo en el directorio <code>src/stories</code>. Recuerda no guardarlas en git. Solo guarda lo que pertenece a nuestro proyecto.</p>"}]}